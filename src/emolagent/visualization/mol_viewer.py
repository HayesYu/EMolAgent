"""
åˆ†å­å¯è§†åŒ–æ¨¡å—

ä½¿ç”¨ py3Dmol æä¾› Gaussian View é£æ ¼çš„åˆ†å­ç»“æ„å¯è§†åŒ–ã€‚
"""

import os
import json
import glob
from typing import Optional, List, Dict, Any, Tuple
from ase.db import connect
from ase import Atoms
import py3Dmol
import numpy as np

from emolagent.utils.logger import logger
from emolagent.utils.config import VisualizationConfig

# Element colors (CPK coloring scheme similar to Gaussian View)
ELEMENT_COLORS = {
    'H': '#FFFFFF',
    'C': '#909090',
    'N': '#3050F8',
    'O': '#FF0D0D',
    'F': '#90E050',
    'S': '#FFFF30',
    'P': '#FF8000',
    'Cl': '#1FF01F',
    'Br': '#A62929',
    'I': '#940094',
    'Li': '#8F40D4',
    'Na': '#AB5CF2',
    'K': '#8F40D4',
    'Mg': '#8AFF00',
    'Ca': '#3DFF00',
    'Fe': '#E06633',
    'Zn': '#7D80B0',
    'default': '#FF1493'
}

# Atom radii (in Angstroms, scaled for visualization)
ELEMENT_RADII = {
    'H': 0.31, 'C': 0.77, 'N': 0.71, 'O': 0.66, 'F': 0.57,
    'S': 1.05, 'P': 1.07, 'Cl': 1.02, 'Br': 1.20, 'I': 1.39,
    'Li': 1.34, 'Na': 1.54, 'K': 1.96, 'Mg': 1.30, 'Ca': 1.74,
    'Fe': 1.25, 'Zn': 1.22, 'default': 1.0
}


def atoms_to_xyz_string(atoms: Atoms, comment: str = "") -> str:
    """å°† ASE Atoms å¯¹è±¡è½¬æ¢ä¸º XYZ æ ¼å¼å­—ç¬¦ä¸²ã€‚"""
    n_atoms = len(atoms)
    lines = [str(n_atoms), comment]
    
    symbols = atoms.get_chemical_symbols()
    positions = atoms.get_positions()
    
    for sym, pos in zip(symbols, positions):
        lines.append(f"{sym:2s} {pos[0]:12.6f} {pos[1]:12.6f} {pos[2]:12.6f}")
    
    return "\n".join(lines)


def atomic_number_to_symbol(z: int) -> str:
    """å°†åŸå­åºæ•°è½¬æ¢ä¸ºå…ƒç´ ç¬¦å·ã€‚"""
    symbols = ['X', 'H', 'He', 'Li', 'Be', 'B', 'C', 'N', 'O', 'F', 'Ne',
               'Na', 'Mg', 'Al', 'Si', 'P', 'S', 'Cl', 'Ar', 'K', 'Ca',
               'Sc', 'Ti', 'V', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn',
               'Ga', 'Ge', 'As', 'Se', 'Br', 'Kr']
    if 0 <= z < len(symbols):
        return symbols[z]
    return 'X'


def create_gaussian_view_style_viewer(
    atoms: Atoms,
    width: int = 600,
    height: int = 500,
    style: str = "sphere+stick",
    background_color: str = "#1a1a2e",
    show_labels: bool = False,
    add_lighting: bool = True,
) -> str:
    """
    åˆ›å»º Gaussian View é£æ ¼çš„ 3D åˆ†å­æŸ¥çœ‹å™¨ HTMLã€‚
    
    Args:
        atoms: ASE Atoms å¯¹è±¡
        width: æŸ¥çœ‹å™¨å®½åº¦ï¼ˆåƒç´ ï¼‰
        height: æŸ¥çœ‹å™¨é«˜åº¦ï¼ˆåƒç´ ï¼‰
        style: æ¸²æŸ“æ ·å¼ ("sphere", "stick", "sphere+stick")
        background_color: èƒŒæ™¯é¢œè‰²
        show_labels: æ˜¯å¦æ˜¾ç¤ºåŸå­æ ‡ç­¾
        add_lighting: æ˜¯å¦æ·»åŠ å¢å¼ºå…‰ç…§æ•ˆæœ
        
    Returns:
        åŒ…å«äº¤äº’å¼ 3D æŸ¥çœ‹å™¨çš„ HTML å­—ç¬¦ä¸²
    """
    xyz_str = atoms_to_xyz_string(atoms, "Generated by EMolAgent")
    
    viewer = py3Dmol.view(width=width, height=height)
    viewer.addModel(xyz_str, "xyz")
    
    if style == "sphere":
        viewer.setStyle({'sphere': {'colorscheme': 'Jmol', 'scale': 0.3}})
    elif style == "stick":
        viewer.setStyle({
            'stick': {'radius': 0.15, 'colorscheme': 'Jmol'},
        })
    else:
        viewer.setStyle({
            'sphere': {'colorscheme': 'Jmol', 'scale': 0.25},
            'stick': {'radius': 0.12, 'colorscheme': 'Jmol'}
        })
    
    viewer.setBackgroundColor(background_color)
    
    if show_labels:
        viewer.addPropertyLabels('elem', '', {'fontSize': 12, 'fontColor': 'white', 'showBackground': False})
    
    viewer.zoomTo()
    
    html = viewer._make_html()
    
    wrapper_html = f"""
    <div style="border: 2px solid #4a4a6a; border-radius: 8px; padding: 10px; background: #0d0d1a;">
        <div style="color: #aaa; font-size: 12px; margin-bottom: 5px; text-align: center;">
            ğŸ–±ï¸ å·¦é”®æ‹–åŠ¨æ—‹è½¬ | æ»šè½®ç¼©æ”¾ | å³é”®å¹³ç§»
        </div>
        {html}
        <div style="color: #888; font-size: 11px; margin-top: 5px; text-align: center;">
            åŸå­æ•°: {len(atoms)} | åŒ–å­¦å¼: {atoms.get_chemical_formula()}
        </div>
    </div>
    """
    
    return wrapper_html


def load_structure_from_db(db_path: str, index: int = 0) -> Optional[Atoms]:
    """ä» ASE æ•°æ®åº“åŠ è½½ç»“æ„ã€‚"""
    if not os.path.exists(db_path):
        return None
    
    try:
        with connect(db_path) as db:
            if db.count() == 0:
                return None
            row = list(db.select())[index]
            return row.toatoms()
    except Exception as e:
        logger.error(f"Error loading structure: {e}")
        return None


def load_all_structures_from_db(db_path: str, max_count: int = 3) -> List[Tuple[Atoms, Dict[str, Any]]]:
    """
    ä» ASE æ•°æ®åº“åŠ è½½æ‰€æœ‰ç»“æ„åŠå…¶å…ƒæ•°æ®ã€‚
    
    Args:
        db_path: æ•°æ®åº“æ–‡ä»¶è·¯å¾„
        max_count: æœ€å¤§åŠ è½½æ•°é‡ï¼Œé»˜è®¤ä¸º 3
        
    Returns:
        åŒ…å« (Atoms, metadata_dict) å…ƒç»„çš„åˆ—è¡¨
    """
    structures: List[Tuple[Atoms, Dict[str, Any]]] = []
    
    if not os.path.exists(db_path):
        return structures
    
    try:
        with connect(db_path) as db:
            total_count = db.count()
            if total_count == 0:
                return structures
            
            for i, row in enumerate(db.select()):
                if i >= max_count:
                    break
                    
                atoms = row.toatoms()
                
                # æå–å…ƒæ•°æ®
                metadata: Dict[str, Any] = {
                    'id': row.id,
                    'name': row.get('name', f'Structure {row.id}'),
                    'category': row.get('category', ''),
                    'solvent_name': row.get('solvent_name', ''),
                    'anion_name': row.get('anion_name', ''),
                    'n_solv': row.get('n_solv', 0),
                    'n_anion': row.get('n_anion', 0),
                    'ion': row.get('ion', 'Li'),
                    'charge': row.get('charge', 0),
                }
                
                structures.append((atoms, metadata))
            
            # è®°å½•æ€»æ•°ä¿¡æ¯ï¼ˆç”¨äºæ˜¾ç¤º"è¿˜æœ‰ N ä¸ªæœªæ˜¾ç¤º"ï¼‰
            if structures:
                structures[0][1]['_total_count'] = total_count
                
    except Exception as e:
        logger.error(f"Error loading structures from db: {e}")
    
    return structures


def get_structure_count_from_db(db_path: str) -> int:
    """è·å–æ•°æ®åº“ä¸­çš„ç»“æ„æ€»æ•°ã€‚"""
    if not os.path.exists(db_path):
        return 0
    
    try:
        with connect(db_path) as db:
            return db.count()
    except Exception as e:
        logger.error(f"Error counting structures: {e}")
        return 0


def create_orbital_viewer(
    cube_path: str,
    width: int = 600,
    height: int = 500,
    iso_value: float = 0.02,
    orbital_type: str = "HOMO",
    background_color: str = "#1a1a2e",
) -> str:
    """
    åˆ›å»ºåˆ†å­è½¨é“ï¼ˆcube æ–‡ä»¶ï¼‰å¯è§†åŒ–æŸ¥çœ‹å™¨ã€‚
    
    Args:
        cube_path: cube æ–‡ä»¶è·¯å¾„
        width: æŸ¥çœ‹å™¨å®½åº¦
        height: æŸ¥çœ‹å™¨é«˜åº¦
        iso_value: ç­‰å€¼é¢æ•°å€¼
        orbital_type: è½¨é“ç±»å‹ ("HOMO" æˆ– "LUMO")
        background_color: èƒŒæ™¯é¢œè‰²
        
    Returns:
        åŒ…å«äº¤äº’å¼ 3D è½¨é“æŸ¥çœ‹å™¨çš„ HTML å­—ç¬¦ä¸²
    """
    if not os.path.exists(cube_path):
        return f"<p style='color: red;'>Cube æ–‡ä»¶ä¸å­˜åœ¨: {cube_path}</p>"
    
    try:
        with open(cube_path, 'r') as f:
            cube_content = f.read()
        
        viewer = py3Dmol.view(width=width, height=height)
        
        if orbital_type.upper() == "HOMO":
            pos_color = "#1E90FF"
            neg_color = "#FF6347"
        else:
            pos_color = "#32CD32"
            neg_color = "#FFD700"
        
        viewer.addVolumetricData(cube_content, "cube", {
            'isoval': iso_value,
            'color': pos_color,
            'opacity': 0.75,
            'smoothness': 3
        })
        viewer.addVolumetricData(cube_content, "cube", {
            'isoval': -iso_value,
            'color': neg_color,
            'opacity': 0.75,
            'smoothness': 3
        })
        
        viewer.addModel(cube_content, "cube")
        viewer.setStyle({
            'sphere': {'colorscheme': 'Jmol', 'scale': 0.2},
            'stick': {'radius': 0.1, 'colorscheme': 'Jmol'}
        })
        
        viewer.setBackgroundColor(background_color)
        viewer.zoomTo()
        
        html = viewer._make_html()
        
        wrapper_html = f"""
        <div style="border: 2px solid #4a4a6a; border-radius: 8px; padding: 10px; background: #0d0d1a;">
            <div style="color: #aaa; font-size: 12px; margin-bottom: 5px; text-align: center;">
                ğŸ–±ï¸ å·¦é”®æ‹–åŠ¨æ—‹è½¬ | æ»šè½®ç¼©æ”¾ | å³é”®å¹³ç§»
            </div>
            {html}
            <div style="color: #888; font-size: 11px; margin-top: 5px; text-align: center;">
                {orbital_type} è½¨é“ | ç­‰å€¼é¢: Â±{iso_value} &nbsp;
                <span style="color: {pos_color};">â– </span> æ­£ç›¸ä½ &nbsp;
                <span style="color: {neg_color};">â– </span> è´Ÿç›¸ä½
            </div>
        </div>
        """
        
        return wrapper_html
        
    except Exception as e:
        return f"<p style='color: red;'>åŠ è½½è½¨é“å¯è§†åŒ–å¤±è´¥: {e}</p>"


def find_orbital_files(inference_dir: str) -> Dict[str, List[Dict[str, str]]]:
    """
    åœ¨æ¨æ–­ç»“æœç›®å½•ä¸­æŸ¥æ‰¾æ‰€æœ‰ HOMO å’Œ LUMO cube æ–‡ä»¶ã€‚
    
    Returns:
        åŒ…å« 'homo' å’Œ 'lumo' é”®çš„å­—å…¸ï¼Œæ¯ä¸ªå€¼æ˜¯æ–‡ä»¶ä¿¡æ¯åˆ—è¡¨
        æ¯ä¸ªæ–‡ä»¶ä¿¡æ¯åŒ…å« 'path', 'id', 'dir_name' é”®
    """
    result: Dict[str, List[Dict[str, str]]] = {'homo': [], 'lumo': []}
    
    if not os.path.exists(inference_dir):
        return result
    
    search_patterns = [
        os.path.join(inference_dir, "results", "*", "homo.cube"),
        os.path.join(inference_dir, "results", "*", "lumo.cube"),
        os.path.join(inference_dir, "*", "homo.cube"),
        os.path.join(inference_dir, "*", "lumo.cube"),
        os.path.join(inference_dir, "homo.cube"),
        os.path.join(inference_dir, "lumo.cube"),
    ]
    
    found_homo = set()
    found_lumo = set()
    
    for pattern in search_patterns:
        matches = glob.glob(pattern)
        for match in matches:
            basename = os.path.basename(match).lower()
            parent_dir = os.path.basename(os.path.dirname(match))
            
            # å°è¯•ä»ç›®å½•åæå– id
            try:
                file_id = int(parent_dir) if parent_dir.isdigit() else len(found_homo) + len(found_lumo)
            except:
                file_id = len(found_homo) + len(found_lumo)
            
            if 'homo' in basename and match not in found_homo:
                found_homo.add(match)
                result['homo'].append({
                    'path': match,
                    'id': str(file_id),
                    'dir_name': parent_dir,
                })
            elif 'lumo' in basename and match not in found_lumo:
                found_lumo.add(match)
                result['lumo'].append({
                    'path': match,
                    'id': str(file_id),
                    'dir_name': parent_dir,
                })
    
    # æŒ‰ id æ’åº
    result['homo'].sort(key=lambda x: int(x['id']) if x['id'].isdigit() else 0)
    result['lumo'].sort(key=lambda x: int(x['id']) if x['id'].isdigit() else 0)
    
    return result


def find_li_deformation_files(inference_dir: str) -> List[Dict[str, str]]:
    """
    åœ¨æ¨æ–­ç»“æœç›®å½•ä¸­æŸ¥æ‰¾ Li deformation surface PDB æ–‡ä»¶ã€‚
    
    æ–‡ä»¶åæ ¼å¼: Li_infer_{li_index}_diff{isovalue}_surface.pdb
    æ–‡ä»¶ä½äº results/{structure_id}/ ç›®å½•ä¸‹
    
    Returns:
        åŒ…å« 'path', 'id', 'isovalue', 'li_index' é”®çš„å­—å…¸åˆ—è¡¨
        å…¶ä¸­ 'id' æ˜¯ç»“æ„ IDï¼ˆç›®å½•åï¼‰ï¼Œç”¨äºåŒ¹é… structure_labels
    """
    result: List[Dict[str, str]] = []
    
    if not os.path.exists(inference_dir):
        return result
    
    search_patterns = [
        os.path.join(inference_dir, "results", "*", "Li_*_surface.pdb"),
        os.path.join(inference_dir, "*", "Li_*_surface.pdb"),
        os.path.join(inference_dir, "Li_*_surface.pdb"),
    ]
    
    found_files = set()
    for pattern in search_patterns:
        matches = glob.glob(pattern)
        for match in matches:
            if match not in found_files:
                found_files.add(match)
                basename = os.path.basename(match)
                parent_dir = os.path.basename(os.path.dirname(match))
                
                # è§£ææ–‡ä»¶å: Li_infer_1_diff0p09_surface.pdb
                # å…¶ä¸­ _1_ æ˜¯ Li åŸå­çš„ 1-based ç´¢å¼•ï¼ˆä¸æ˜¯ç»“æ„ IDï¼‰
                import re
                m = re.match(r'Li_(\w+)_(\d+)_diff(\w+)_surface\.pdb', basename)
                if m:
                    # ä½¿ç”¨çˆ¶ç›®å½•åä½œä¸ºç»“æ„ IDï¼ˆä¸ structure_labels å¯¹åº”ï¼‰
                    structure_id = parent_dir if parent_dir.isdigit() else str(len(result))
                    result.append({
                        'path': match,
                        'type': m.group(1),       # infer/pred/target
                        'li_index': m.group(2),   # Li åŸå­ç´¢å¼•ï¼ˆ1-basedï¼‰
                        'id': structure_id,       # ç»“æ„ IDï¼ˆç›®å½•åï¼Œ0-basedï¼‰
                        'isovalue': m.group(3).replace('p', '.'),  # 0p09 -> 0.09
                    })
    
    # æŒ‰ç»“æ„ id æ’åº
    result.sort(key=lambda x: int(x.get('id', 0)))
    return result


def create_li_deformation_viewer(
    molecule_path: str,
    surface_pdb_path: str,
    width: int = 600,
    height: int = 500,
    surface_color: str = "#4A90D9",
    surface_opacity: float = 0.65,
    background_color: str = "#1a1a2e",
    isovalue: str = "0.09",
) -> str:
    """
    åˆ›å»º Li deformation factor å¯è§†åŒ–æŸ¥çœ‹å™¨ã€‚
    
    å°†ç‚¹äº‘ PDB æ¸²æŸ“ä¸ºåŠé€æ˜è¡¨é¢ï¼Œå åŠ åœ¨åˆ†å­ç»“æ„ä¸Šï¼Œ
    ç”¨äºå±•ç¤º Li ç¦»å­å‘¨å›´çš„ç”µå­å˜å½¢åˆ†å¸ƒã€‚
    
    Args:
        molecule_path: åˆ†å­ç»“æ„æ–‡ä»¶è·¯å¾„ (xyz æˆ– pdb)
        surface_pdb_path: Li deformation ç‚¹äº‘ PDB æ–‡ä»¶è·¯å¾„
        width: æŸ¥çœ‹å™¨å®½åº¦
        height: æŸ¥çœ‹å™¨é«˜åº¦
        surface_color: è¡¨é¢é¢œè‰²ï¼ˆé»˜è®¤å†·è“è‰²ï¼‰
        surface_opacity: è¡¨é¢é€æ˜åº¦
        background_color: èƒŒæ™¯é¢œè‰²
        isovalue: ç­‰å€¼é¢å€¼ï¼ˆç”¨äºæ˜¾ç¤ºï¼‰
        
    Returns:
        åŒ…å«äº¤äº’å¼ 3D æŸ¥çœ‹å™¨çš„ HTML å­—ç¬¦ä¸²
    """
    # æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
    if not os.path.exists(molecule_path):
        return f"<p style='color: red;'>åˆ†å­ç»“æ„æ–‡ä»¶ä¸å­˜åœ¨: {molecule_path}</p>"
    if not os.path.exists(surface_pdb_path):
        return f"<p style='color: red;'>è¡¨é¢ç‚¹äº‘æ–‡ä»¶ä¸å­˜åœ¨: {surface_pdb_path}</p>"
    
    try:
        # 1. è¯»å–åˆ†å­ç»“æ„
        mol_ext = os.path.splitext(molecule_path)[1].lower()
        with open(molecule_path, 'r') as f:
            mol_content = f.read()
        
        # ç¡®å®šåˆ†å­æ–‡ä»¶æ ¼å¼
        if mol_ext == '.xyz':
            mol_format = 'xyz'
        elif mol_ext == '.pdb':
            mol_format = 'pdb'
        else:
            # å°è¯•è‡ªåŠ¨æ£€æµ‹
            mol_format = 'xyz' if mol_content.strip().split('\n')[0].strip().isdigit() else 'pdb'
        
        # 2. è¯»å–è¡¨é¢ç‚¹äº‘ PDB
        with open(surface_pdb_path, 'r') as f:
            surface_content = f.read()
        
        # 3. åˆ›å»º py3Dmol è§†å›¾
        viewer = py3Dmol.view(width=width, height=height)
        
        # 4. æ·»åŠ åˆ†å­éª¨æ¶ (Model 0)
        viewer.addModel(mol_content, mol_format)
        viewer.setStyle({'model': 0}, {
            'sphere': {'colorscheme': 'Jmol', 'scale': 0.25},
            'stick': {'radius': 0.12, 'colorscheme': 'Jmol'}
        })
        
        # 5. æ·»åŠ ç‚¹äº‘å¹¶æ¸²æŸ“ä¸ºè¡¨é¢ (Model 1)
        viewer.addModel(surface_content, 'pdb')
        # éšè—ç‚¹äº‘æœ¬èº«çš„åŸå­æ˜¾ç¤º
        viewer.setStyle({'model': 1}, {'sphere': {'scale': 0}})
        
        # 6. ä¸ºç‚¹äº‘æ·»åŠ  VDW è¡¨é¢ï¼ˆè¿‘ä¼¼ QuickSurf æ•ˆæœï¼‰
        # py3Dmol çš„ addSurface æ”¯æŒ: VDW, MS (åˆ†å­è¡¨é¢), SAS, SES
        viewer.addSurface(
            'VDW',
            {
                'opacity': surface_opacity,
                'color': surface_color,
            },
            {'model': 1}
        )
        
        # 7. è®¾ç½®èƒŒæ™¯å’Œè§†å›¾
        viewer.setBackgroundColor(background_color)
        viewer.zoomTo()
        
        # 8. ç”Ÿæˆ HTML
        html = viewer._make_html()
        
        wrapper_html = f"""
        <div style="border: 2px solid #4a4a6a; border-radius: 8px; padding: 10px; background: #0d0d1a;">
            <div style="color: #aaa; font-size: 12px; margin-bottom: 5px; text-align: center;">
                ğŸ–±ï¸ å·¦é”®æ‹–åŠ¨æ—‹è½¬ | æ»šè½®ç¼©æ”¾ | å³é”®å¹³ç§»
            </div>
            {html}
            <div style="color: #888; font-size: 11px; margin-top: 5px; text-align: center;">
                Li Deformation Factor | ç­‰å€¼é¢: {isovalue} &nbsp;
                <span style="display: inline-block; width: 12px; height: 12px; background: {surface_color}; border-radius: 2px; vertical-align: middle;"></span>
                <span style="color: {surface_color};"> å˜å½¢åŒºåŸŸ</span>
            </div>
        </div>
        """
        
        return wrapper_html
        
    except Exception as e:
        return f"<p style='color: red;'>åŠ è½½ Li Deformation å¯è§†åŒ–å¤±è´¥: {e}</p>"


def find_esp_files(inference_dir: str) -> List[Dict[str, Optional[str]]]:
    """
    åœ¨æ¨æ–­ç»“æœç›®å½•ä¸­æŸ¥æ‰¾æ‰€æœ‰ ESP å¯è§†åŒ–æ‰€éœ€çš„æ–‡ä»¶ã€‚
    
    Returns:
        æ–‡ä»¶ç»„åˆ—è¡¨ï¼Œæ¯ç»„åŒ…å« 'density', 'esp', 'info', 'id', 'dir_name' é”®
    """
    result: List[Dict[str, Optional[str]]] = []
    
    if not os.path.exists(inference_dir):
        return result
    
    # æœç´¢æ¨¡å¼
    search_dirs = [
        os.path.join(inference_dir, "results", "*"),
        os.path.join(inference_dir, "*"),
    ]
    
    found_dirs = set()
    
    for search_dir in search_dirs:
        dirs = glob.glob(search_dir) if '*' in search_dir else [search_dir]
        for d in dirs:
            if not os.path.isdir(d) or d in found_dirs:
                continue
            
            dir_name = os.path.basename(d)
            
            # æŸ¥æ‰¾ density cube æ–‡ä»¶
            density_file = None
            density_candidates = [
                os.path.join(d, "infer_ESPCalculator_density.cub"),
                os.path.join(d, "density.cub"),
                os.path.join(d, "density.cube"),
            ]
            for f in density_candidates:
                if os.path.exists(f):
                    density_file = f
                    break
            
            # æŸ¥æ‰¾ ESP cube æ–‡ä»¶
            esp_file = None
            esp_candidates = [
                os.path.join(d, "infer_ESPCalculator_totesp.cub"),
                os.path.join(d, "totesp.cub"),
                os.path.join(d, "esp.cub"),
                os.path.join(d, "esp.cube"),
            ]
            for f in esp_candidates:
                if os.path.exists(f):
                    esp_file = f
                    break
            
            # æŸ¥æ‰¾ info json æ–‡ä»¶
            info_file = None
            info_candidates = [
                os.path.join(d, "infer_esp_info.json"),
                os.path.join(d, "esp_info.json"),
            ]
            for f in info_candidates:
                if os.path.exists(f):
                    info_file = f
                    break
            
            # å¦‚æœæ‰¾åˆ° density å’Œ esp æ–‡ä»¶ï¼Œæ·»åŠ åˆ°ç»“æœ
            if density_file and esp_file:
                found_dirs.add(d)
                try:
                    file_id = int(dir_name) if dir_name.isdigit() else len(result)
                except:
                    file_id = len(result)
                
                result.append({
                    'density': density_file,
                    'esp': esp_file,
                    'info': info_file,
                    'id': str(file_id),
                    'dir_name': dir_name,
                })
    
    # ä¹Ÿæ£€æŸ¥æ ¹ç›®å½•
    density_file = None
    esp_file = None
    info_file = None
    
    for f in [os.path.join(inference_dir, "infer_ESPCalculator_density.cub"),
              os.path.join(inference_dir, "density.cub")]:
        if os.path.exists(f):
            density_file = f
            break
    
    for f in [os.path.join(inference_dir, "infer_ESPCalculator_totesp.cub"),
              os.path.join(inference_dir, "totesp.cub")]:
        if os.path.exists(f):
            esp_file = f
            break
    
    for f in [os.path.join(inference_dir, "infer_esp_info.json"),
              os.path.join(inference_dir, "esp_info.json")]:
        if os.path.exists(f):
            info_file = f
            break
    
    if density_file and esp_file:
        result.append({
            'density': density_file,
            'esp': esp_file,
            'info': info_file,
            'id': str(len(result)),
            'dir_name': 'root',
        })
    
    # æŒ‰ id æ’åº
    result.sort(key=lambda x: int(x['id']) if x['id'].isdigit() else 0)
    
    return result


def load_esp_info(info_path: str) -> Optional[Dict[str, Any]]:
    """
    åŠ è½½ ESP info JSON æ–‡ä»¶ã€‚
    
    Returns:
        åŒ…å« ESP æœ€å¤§/æœ€å°å€¼åŠä½ç½®çš„å­—å…¸
    """
    if not info_path or not os.path.exists(info_path):
        return None
    
    try:
        with open(info_path, 'r') as f:
            return json.load(f)
    except Exception as e:
        logger.error(f"Error loading ESP info: {e}")
        return None


def parse_cube_file(cube_path: str) -> Tuple[List[Dict], np.ndarray, Dict]:
    """
    è§£æ Gaussian cube æ–‡ä»¶æ ¼å¼ã€‚
    
    Returns:
        (atoms_list, grid_data, grid_info)
        - atoms_list: åŸå­åˆ—è¡¨ï¼Œæ¯ä¸ªåŸå­åŒ…å« {'symbol', 'x', 'y', 'z'}
        - grid_data: 3D numpy æ•°ç»„çš„ç½‘æ ¼æ•°æ®
        - grid_info: ç½‘æ ¼ä¿¡æ¯å­—å…¸
    """
    with open(cube_path, 'r') as f:
        lines = f.readlines()
    
    # è·³è¿‡å‰ä¸¤è¡Œæ³¨é‡Š
    # ç¬¬3è¡Œ: åŸå­æ•°å’ŒåŸç‚¹åæ ‡
    parts = lines[2].split()
    n_atoms = abs(int(parts[0]))
    origin = [float(parts[1]), float(parts[2]), float(parts[3])]
    
    # ç¬¬4-6è¡Œ: å„è½´çš„ç½‘æ ¼ç‚¹æ•°å’Œæ­¥é•¿å‘é‡
    nx, vx = int(lines[3].split()[0]), [float(x) for x in lines[3].split()[1:4]]
    ny, vy = int(lines[4].split()[0]), [float(x) for x in lines[4].split()[1:4]]
    nz, vz = int(lines[5].split()[0]), [float(x) for x in lines[5].split()[1:4]]
    
    grid_info = {
        'origin': origin,
        'n_points': (nx, ny, nz),
        'vectors': (vx, vy, vz)
    }
    
    # è§£æåŸå­ä¿¡æ¯
    atoms_list = []
    for i in range(n_atoms):
        parts = lines[6 + i].split()
        z = int(float(parts[0]))
        x, y, z_coord = float(parts[2]), float(parts[3]), float(parts[4])
        atoms_list.append({
            'symbol': atomic_number_to_symbol(z),
            'x': x * 0.529177,  # Bohr to Angstrom
            'y': y * 0.529177,
            'z': z_coord * 0.529177
        })
    
    # è§£æç½‘æ ¼æ•°æ®
    data_start = 6 + n_atoms
    data_values = []
    for line in lines[data_start:]:
        data_values.extend([float(x) for x in line.split()])
    
    grid_data = np.array(data_values).reshape((nx, ny, nz))
    
    return atoms_list, grid_data, grid_info


def atoms_list_to_xyz_string(atoms_list: List[Dict], comment: str = "") -> str:
    """å°†åŸå­åˆ—è¡¨è½¬æ¢ä¸º XYZ æ ¼å¼å­—ç¬¦ä¸²ã€‚"""
    n_atoms = len(atoms_list)
    lines = [str(n_atoms), comment]
    
    for atom in atoms_list:
        lines.append(f"{atom['symbol']:2s} {atom['x']:12.6f} {atom['y']:12.6f} {atom['z']:12.6f}")
    
    return "\n".join(lines)


def value_to_bwr_color(value: float, vmin: float, vmax: float) -> str:
    """
    å°†æ•°å€¼æ˜ å°„åˆ° BWR (è“-ç™½-çº¢) è‰²é˜¶ã€‚
    
    Args:
        value: è¦æ˜ å°„çš„å€¼
        vmin: æœ€å°å€¼ï¼ˆå¯¹åº”è“è‰²ï¼‰
        vmax: æœ€å¤§å€¼ï¼ˆå¯¹åº”çº¢è‰²ï¼‰
        
    Returns:
        åå…­è¿›åˆ¶é¢œè‰²å­—ç¬¦ä¸²
    """
    # å½’ä¸€åŒ–åˆ° [-1, 1]
    if vmax == vmin:
        norm = 0
    else:
        mid = (vmax + vmin) / 2
        half_range = (vmax - vmin) / 2
        if half_range == 0:
            norm = 0
        else:
            norm = (value - mid) / half_range
    
    norm = max(-1, min(1, norm))  # clamp
    
    if norm < 0:
        # è“åˆ°ç™½ï¼šå¢åŠ çº¢å’Œç»¿
        r = int(255 * (1 + norm))
        g = int(255 * (1 + norm))
        b = 255
    else:
        # ç™½åˆ°çº¢ï¼šå‡å°‘ç»¿å’Œè“
        r = 255
        g = int(255 * (1 - norm))
        b = int(255 * (1 - norm))
    
    return f"#{r:02x}{g:02x}{b:02x}"


def parse_cube_file_full(cube_path: str) -> Tuple[List[Dict], np.ndarray, Dict]:
    """
    è§£æ Gaussian cube æ–‡ä»¶æ ¼å¼ï¼Œè¿”å›å®Œæ•´çš„ç½‘æ ¼ä¿¡æ¯ï¼ˆç”¨äº marching cubesï¼‰ã€‚
    
    Returns:
        (atoms_list, grid_data, grid_info)
        - atoms_list: åŸå­åˆ—è¡¨ï¼Œæ¯ä¸ªåŸå­åŒ…å« {'symbol', 'x', 'y', 'z'} (Angstrom)
        - grid_data: 3D numpy æ•°ç»„çš„ç½‘æ ¼æ•°æ®
        - grid_info: ç½‘æ ¼ä¿¡æ¯å­—å…¸ï¼ŒåŒ…å« origin, n_points, spacing (å…¨éƒ¨ Bohr å•ä½)
    """
    with open(cube_path, 'r') as f:
        lines = f.readlines()
    
    # ç¬¬3è¡Œ: åŸå­æ•°å’ŒåŸç‚¹åæ ‡ (Bohr)
    parts = lines[2].split()
    n_atoms = abs(int(parts[0]))
    origin = np.array([float(parts[1]), float(parts[2]), float(parts[3])])
    
    # ç¬¬4-6è¡Œ: å„è½´çš„ç½‘æ ¼ç‚¹æ•°å’Œæ­¥é•¿å‘é‡ (Bohr)
    nx = int(lines[3].split()[0])
    dx = float(lines[3].split()[1])  # å‡è®¾æ˜¯æ­£äº¤ç½‘æ ¼ï¼Œåªå–å¯¹è§’å…ƒç´ 
    
    ny = int(lines[4].split()[0])
    dy = float(lines[4].split()[2])
    
    nz = int(lines[5].split()[0])
    dz = float(lines[5].split()[3])
    
    grid_info = {
        'origin': origin,  # Bohr
        'n_points': (nx, ny, nz),
        'spacing': (dx, dy, dz),  # Bohr
    }
    
    # è§£æåŸå­ä¿¡æ¯
    BOHR_TO_ANG = 0.529177
    atoms_list = []
    for i in range(n_atoms):
        parts = lines[6 + i].split()
        z = int(float(parts[0]))
        x_bohr, y_bohr, z_bohr = float(parts[2]), float(parts[3]), float(parts[4])
        atoms_list.append({
            'symbol': atomic_number_to_symbol(z),
            'x': x_bohr * BOHR_TO_ANG,
            'y': y_bohr * BOHR_TO_ANG,
            'z': z_bohr * BOHR_TO_ANG
        })
    
    # è§£æç½‘æ ¼æ•°æ®
    data_start = 6 + n_atoms
    data_values = []
    for line in lines[data_start:]:
        data_values.extend([float(x) for x in line.split()])
    
    grid_data = np.array(data_values).reshape((nx, ny, nz))
    
    return atoms_list, grid_data, grid_info


def create_esp_viewer(
    density_cube_path: str,
    esp_cube_path: str,
    esp_info_path: Optional[str] = None,
    width: int = 600,
    height: int = 500,
    density_isovalue: float = 0.001,
    esp_colorscale_min: float = -0.03,
    esp_colorscale_max: float = 0.03,
    surface_opacity: float = 0.85,
    background_color: str = "#1a1a2e",
    show_extrema: bool = True,
) -> str:
    """
    åˆ›å»º ESP (é™ç”µåŠ¿) æ˜ å°„åœ¨åˆ†å­ vdW è¡¨é¢ä¸Šçš„å¯è§†åŒ–æŸ¥çœ‹å™¨ã€‚
    
    ä½¿ç”¨ Marching Cubes ä»å¯†åº¦ cube æå–ç­‰å€¼é¢ï¼Œç„¶åç”¨ ESP å€¼å¯¹é¡¶ç‚¹ç€è‰²ï¼Œ
    å®ç°ç±»ä¼¼ VMD çš„ BWR æ¸å˜è‰²æ•ˆæœã€‚
    
    Args:
        density_cube_path: ç”µå­å¯†åº¦ cube æ–‡ä»¶è·¯å¾„
        esp_cube_path: ESP cube æ–‡ä»¶è·¯å¾„
        esp_info_path: ESP info JSON æ–‡ä»¶è·¯å¾„ï¼ˆå¯é€‰ï¼‰
        width: æŸ¥çœ‹å™¨å®½åº¦
        height: æŸ¥çœ‹å™¨é«˜åº¦
        density_isovalue: å¯†åº¦ç­‰å€¼é¢æ•°å€¼ï¼ˆé»˜è®¤ 0.001 å¯¹åº” vdW è¡¨é¢ï¼‰
        esp_colorscale_min: ESP é¢œè‰²æ ‡åº¦æœ€å°å€¼ï¼ˆåŸå­å•ä½ï¼Œé»˜è®¤ -0.03ï¼‰
        esp_colorscale_max: ESP é¢œè‰²æ ‡åº¦æœ€å¤§å€¼ï¼ˆåŸå­å•ä½ï¼Œé»˜è®¤ 0.03ï¼‰
        surface_opacity: è¡¨é¢é€æ˜åº¦
        background_color: èƒŒæ™¯é¢œè‰²
        show_extrema: æ˜¯å¦æ˜¾ç¤º ESP æå€¼ç‚¹
        
    Returns:
        åŒ…å«äº¤äº’å¼ 3D æŸ¥çœ‹å™¨çš„ HTML å­—ç¬¦ä¸²
    """
    if not os.path.exists(density_cube_path):
        return f"<p style='color: red;'>å¯†åº¦ Cube æ–‡ä»¶ä¸å­˜åœ¨: {density_cube_path}</p>"
    if not os.path.exists(esp_cube_path):
        return f"<p style='color: red;'>ESP Cube æ–‡ä»¶ä¸å­˜åœ¨: {esp_cube_path}</p>"
    
    try:
        from skimage.measure import marching_cubes
        from scipy.interpolate import RegularGridInterpolator
        import plotly.graph_objects as go
        
        BOHR_TO_ANG = 0.529177
        
        # 1. è§£æ cube æ–‡ä»¶
        atoms_list, density_data, density_info = parse_cube_file_full(density_cube_path)
        _, esp_data, esp_info_grid = parse_cube_file_full(esp_cube_path)
        
        # åŠ è½½ ESP info (æå€¼ä¿¡æ¯)
        esp_info = None
        if esp_info_path:
            esp_info = load_esp_info(esp_info_path)
        
        # 2. ä½¿ç”¨ Marching Cubes æå–å¯†åº¦ç­‰å€¼é¢
        origin = density_info['origin']
        nx, ny, nz = density_info['n_points']
        dx, dy, dz = density_info['spacing']
        
        # marching_cubes è¿”å›çš„é¡¶ç‚¹æ˜¯ä»¥ç½‘æ ¼ç´¢å¼•ä¸ºå•ä½ï¼Œéœ€è¦è½¬æ¢
        verts, faces, normals, values = marching_cubes(
            density_data,
            level=density_isovalue,
            spacing=(dx, dy, dz)  # Bohr
        )
        
        # å°†é¡¶ç‚¹åæ ‡ä»ç½‘æ ¼ç©ºé—´è½¬æ¢åˆ°å®é™…åæ ‡ (Bohr -> Angstrom)
        verts_bohr = verts + origin  # åŠ ä¸ŠåŸç‚¹åç§»
        verts_ang = verts_bohr * BOHR_TO_ANG
        
        # 3. æ„å»º ESP æ’å€¼å™¨ï¼Œåœ¨ç­‰å€¼é¢é¡¶ç‚¹é‡‡æ · ESP å€¼
        # ESP ç½‘æ ¼åæ ‡ (Bohr)
        esp_origin = esp_info_grid['origin']
        esp_nx, esp_ny, esp_nz = esp_info_grid['n_points']
        esp_dx, esp_dy, esp_dz = esp_info_grid['spacing']
        
        x_esp = np.linspace(esp_origin[0], esp_origin[0] + (esp_nx - 1) * esp_dx, esp_nx)
        y_esp = np.linspace(esp_origin[1], esp_origin[1] + (esp_ny - 1) * esp_dy, esp_ny)
        z_esp = np.linspace(esp_origin[2], esp_origin[2] + (esp_nz - 1) * esp_dz, esp_nz)
        
        esp_interp = RegularGridInterpolator(
            (x_esp, y_esp, z_esp), 
            esp_data,
            method='linear',
            bounds_error=False,
            fill_value=0.0
        )
        
        # åœ¨ç­‰å€¼é¢é¡¶ç‚¹é‡‡æ · ESP å€¼ (ä½¿ç”¨ Bohr åæ ‡)
        esp_at_verts = esp_interp(verts_bohr)
        
        # 4. å°† ESP å€¼æ˜ å°„åˆ° BWR é¢œè‰²
        # å½’ä¸€åŒ– ESP å€¼åˆ° [0, 1] èŒƒå›´
        esp_normalized = (esp_at_verts - esp_colorscale_min) / (esp_colorscale_max - esp_colorscale_min)
        esp_normalized = np.clip(esp_normalized, 0, 1)
        
        # BWR é¢œè‰²æ˜ å°„ï¼šè“(0) -> ç™½(0.5) -> çº¢(1)
        colors = np.zeros((len(esp_normalized), 3))
        
        # è“åˆ°ç™½ (esp_normalized < 0.5)
        mask_low = esp_normalized < 0.5
        t = esp_normalized[mask_low] * 2  # 0->0, 0.5->1
        colors[mask_low, 0] = t  # R: 0->1
        colors[mask_low, 1] = t  # G: 0->1
        colors[mask_low, 2] = 1  # B: 1
        
        # ç™½åˆ°çº¢ (esp_normalized >= 0.5)
        mask_high = ~mask_low
        t = (esp_normalized[mask_high] - 0.5) * 2  # 0.5->0, 1->1
        colors[mask_high, 0] = 1  # R: 1
        colors[mask_high, 1] = 1 - t  # G: 1->0
        colors[mask_high, 2] = 1 - t  # B: 1->0
        
        # è½¬æ¢ä¸º Plotly æ ¼å¼çš„é¢œè‰²å­—ç¬¦ä¸²
        vertex_colors = [f'rgb({int(c[0]*255)},{int(c[1]*255)},{int(c[2]*255)})' for c in colors]
        
        # 5. åˆ›å»º Plotly 3D å›¾å½¢
        fig = go.Figure()
        
        # æ·»åŠ  ESP ç€è‰²çš„ç­‰å€¼é¢
        fig.add_trace(go.Mesh3d(
            x=verts_ang[:, 0],
            y=verts_ang[:, 1],
            z=verts_ang[:, 2],
            i=faces[:, 0],
            j=faces[:, 1],
            k=faces[:, 2],
            vertexcolor=vertex_colors,
            opacity=surface_opacity,
            name='ESP Surface',
            hoverinfo='skip',
            lighting=dict(
                ambient=0.5,
                diffuse=0.8,
                specular=0.3,
                roughness=0.5,
            ),
            lightposition=dict(x=100, y=200, z=300),
        ))
        
        # æ·»åŠ åˆ†å­éª¨æ¶
        for atom in atoms_list:
            color = ELEMENT_COLORS.get(atom['symbol'], ELEMENT_COLORS['default'])
            radius = ELEMENT_RADII.get(atom['symbol'], ELEMENT_RADII['default']) * 0.3
            
            # åˆ›å»ºçƒä½“çš„è¿‘ä¼¼ï¼ˆä½¿ç”¨ scatter3dï¼‰
            fig.add_trace(go.Scatter3d(
                x=[atom['x']],
                y=[atom['y']],
                z=[atom['z']],
                mode='markers',
                marker=dict(
                    size=radius * 20,
                    color=color,
                    opacity=1.0,
                ),
                name=atom['symbol'],
                hoverinfo='text',
                hovertext=f"{atom['symbol']} ({atom['x']:.2f}, {atom['y']:.2f}, {atom['z']:.2f})",
                showlegend=False,
            ))
        
        # æ·»åŠ é”®ï¼ˆç®€å•ç‰ˆæœ¬ï¼šåŸºäºè·ç¦»åˆ¤æ–­ï¼‰
        bond_x, bond_y, bond_z = [], [], []
        for i, atom1 in enumerate(atoms_list):
            for j, atom2 in enumerate(atoms_list):
                if j <= i:
                    continue
                dist = np.sqrt(
                    (atom1['x'] - atom2['x'])**2 + 
                    (atom1['y'] - atom2['y'])**2 + 
                    (atom1['z'] - atom2['z'])**2
                )
                # ç®€å•çš„é”®é•¿åˆ¤æ–­
                max_bond = 1.8  # Angstrom
                if atom1['symbol'] in ['S', 'P', 'Cl', 'Br', 'I'] or atom2['symbol'] in ['S', 'P', 'Cl', 'Br', 'I']:
                    max_bond = 2.5
                if dist < max_bond:
                    bond_x.extend([atom1['x'], atom2['x'], None])
                    bond_y.extend([atom1['y'], atom2['y'], None])
                    bond_z.extend([atom1['z'], atom2['z'], None])
        
        if bond_x:
            fig.add_trace(go.Scatter3d(
                x=bond_x, y=bond_y, z=bond_z,
                mode='lines',
                line=dict(color='#888888', width=3),
                hoverinfo='skip',
                showlegend=False,
            ))
        
        # æ·»åŠ  ESP æå€¼ç‚¹æ ‡æ³¨
        extrema_html = ""
        if show_extrema and esp_info:
            if 'ESP_max_location_Ang' in esp_info:
                max_loc = esp_info['ESP_max_location_Ang']
                max_val = esp_info.get('ESP_max_eV', 0)
                fig.add_trace(go.Scatter3d(
                    x=[max_loc[0]], y=[max_loc[1]], z=[max_loc[2]],
                    mode='markers+text',
                    marker=dict(size=8, color='#FF0000', symbol='diamond'),
                    text=[f'Max: {max_val:.2f} eV'],
                    textposition='top center',
                    textfont=dict(color='#FF6666', size=10),
                    hoverinfo='text',
                    hovertext=f'ESP Max: {max_val:.2f} eV',
                    showlegend=False,
                ))
                extrema_html += f'<span style="color: #FF6666;">â—† Max: {max_val:.2f} eV</span> '
            
            if 'ESP_min_location_Ang' in esp_info:
                min_loc = esp_info['ESP_min_location_Ang']
                min_val = esp_info.get('ESP_min_eV', 0)
                fig.add_trace(go.Scatter3d(
                    x=[min_loc[0]], y=[min_loc[1]], z=[min_loc[2]],
                    mode='markers+text',
                    marker=dict(size=8, color='#0000FF', symbol='diamond'),
                    text=[f'Min: {min_val:.2f} eV'],
                    textposition='top center',
                    textfont=dict(color='#6666FF', size=10),
                    hoverinfo='text',
                    hovertext=f'ESP Min: {min_val:.2f} eV',
                    showlegend=False,
                ))
                extrema_html += f'<span style="color: #6666FF;">â—† Min: {min_val:.2f} eV</span>'
        
        # 6. è®¾ç½®å¸ƒå±€
        # è§£æèƒŒæ™¯è‰²
        bg_color = background_color
        
        fig.update_layout(
            scene=dict(
                xaxis=dict(visible=False),
                yaxis=dict(visible=False),
                zaxis=dict(visible=False),
                bgcolor=bg_color,
                aspectmode='data',
            ),
            paper_bgcolor=bg_color,
            plot_bgcolor=bg_color,
            margin=dict(l=0, r=0, t=0, b=0),
            width=width,
            height=height,
            showlegend=False,
        )
        
        # 7. ç”Ÿæˆ HTML
        plotly_html = fig.to_html(
            include_plotlyjs='cdn',
            full_html=False,
            config={
                'displayModeBar': True,
                'modeBarButtonsToRemove': ['select2d', 'lasso2d'],
                'displaylogo': False,
            }
        )
        
        # åˆ›å»ºè‰²é˜¶æ¡ HTML (è½¬æ¢ä¸º eV å•ä½)
        HARTREE_TO_EV = 27.2114
        esp_min_ev = esp_colorscale_min * HARTREE_TO_EV
        esp_max_ev = esp_colorscale_max * HARTREE_TO_EV
        colorbar_html = f"""
        <div style="display: flex; align-items: center; justify-content: center; margin-top: 5px;">
            <span style="color: #4444FF; font-size: 11px;">{esp_min_ev:.2f}</span>
            <div style="
                width: 150px; 
                height: 12px; 
                margin: 0 8px;
                background: linear-gradient(to right, #0000FF, #FFFFFF, #FF0000);
                border-radius: 2px;
            "></div>
            <span style="color: #FF4444; font-size: 11px;">{esp_max_ev:.2f}</span>
            <span style="color: #888; font-size: 10px; margin-left: 5px;">(eV)</span>
        </div>
        """
        
        wrapper_html = f"""
        <div style="border: 2px solid #4a4a6a; border-radius: 8px; padding: 10px; background: #0d0d1a;">
            <div style="color: #aaa; font-size: 12px; margin-bottom: 5px; text-align: center;">
                ğŸ–±ï¸ å·¦é”®æ‹–åŠ¨æ—‹è½¬ | æ»šè½®ç¼©æ”¾ | å³é”®å¹³ç§»
            </div>
            {plotly_html}
            <div style="color: #888; font-size: 11px; margin-top: 5px; text-align: center;">
                é™ç”µåŠ¿ (ESP) | å¯†åº¦ç­‰å€¼é¢: {density_isovalue} | 
                <span style="color: #FF4444;">çº¢</span>=æ­£(äº²æ ¸) | 
                <span style="color: #4444FF;">è“</span>=è´Ÿ(äº²ç”µ)
            </div>
            {colorbar_html}
            {f'<div style="color: #888; font-size: 11px; margin-top: 3px; text-align: center;">{extrema_html}</div>' if extrema_html else ''}
        </div>
        """
        
        return wrapper_html
        
    except ImportError as e:
        missing_pkg = str(e).split("'")[-2] if "'" in str(e) else str(e)
        return f"""
        <div style="border: 2px solid #ff6666; border-radius: 8px; padding: 15px; background: #1a0d0d;">
            <p style='color: #ff6666; margin: 0;'>
                <strong>ç¼ºå°‘ä¾èµ–åŒ…:</strong> {missing_pkg}
            </p>
            <p style='color: #aaa; margin: 10px 0 0 0; font-size: 12px;'>
                è¯·è¿è¡Œ: <code style="background: #333; padding: 2px 6px; border-radius: 3px;">pip install scikit-image scipy plotly</code>
            </p>
        </div>
        """
    except Exception as e:
        import traceback
        logger.error(f"ESP visualization error: {traceback.format_exc()}")
        return f"<p style='color: red;'>åŠ è½½ ESP å¯è§†åŒ–å¤±è´¥: {e}</p>"


def create_esp_viewer_fallback(
    density_cube_path: str,
    esp_cube_path: str,
    esp_info_path: Optional[str] = None,
    width: int = 600,
    height: int = 500,
    density_isovalue: float = 0.001,
    esp_colorscale_min: float = -0.03,
    esp_colorscale_max: float = 0.03,
    surface_opacity: float = 0.85,
    background_color: str = "#1a1a2e",
    show_extrema: bool = True,
) -> str:
    """
    ESP å¯è§†åŒ–çš„åå¤‡æ–¹æ¡ˆï¼ˆä½¿ç”¨ py3Dmolï¼Œæ•ˆæœè¾ƒç®€å•ï¼‰ã€‚
    å½“ scikit-image/plotly ä¸å¯ç”¨æ—¶ä½¿ç”¨ã€‚
    """
    if not os.path.exists(density_cube_path):
        return f"<p style='color: red;'>å¯†åº¦ Cube æ–‡ä»¶ä¸å­˜åœ¨: {density_cube_path}</p>"
    if not os.path.exists(esp_cube_path):
        return f"<p style='color: red;'>ESP Cube æ–‡ä»¶ä¸å­˜åœ¨: {esp_cube_path}</p>"
    
    try:
        with open(density_cube_path, 'r') as f:
            density_content = f.read()
        with open(esp_cube_path, 'r') as f:
            esp_content = f.read()
        
        esp_info = None
        if esp_info_path:
            esp_info = load_esp_info(esp_info_path)
        
        viewer = py3Dmol.view(width=width, height=height)
        
        viewer.addModel(density_content, "cube")
        viewer.setStyle({
            'sphere': {'colorscheme': 'Jmol', 'scale': 0.2},
            'stick': {'radius': 0.1, 'colorscheme': 'Jmol'}
        })
        
        pos_iso = abs(esp_colorscale_max) * 0.5
        viewer.addVolumetricData(esp_content, "cube", {
            'isoval': pos_iso,
            'color': '#FF4444',
            'opacity': 0.6,
            'smoothness': 3
        })
        
        neg_iso = -abs(esp_colorscale_min) * 0.5
        viewer.addVolumetricData(esp_content, "cube", {
            'isoval': neg_iso,
            'color': '#4444FF',
            'opacity': 0.6,
            'smoothness': 3
        })
        
        extrema_html = ""
        if show_extrema and esp_info:
            if 'ESP_max_location_Ang' in esp_info:
                max_loc = esp_info['ESP_max_location_Ang']
                max_val = esp_info.get('ESP_max_eV', 0)
                viewer.addSphere({
                    'center': {'x': max_loc[0], 'y': max_loc[1], 'z': max_loc[2]},
                    'radius': 0.3,
                    'color': '#FF0000',
                    'opacity': 0.9
                })
                extrema_html += f'<span style="color: #FF6666;">â— Max: {max_val:.2f} eV</span> '
            
            if 'ESP_min_location_Ang' in esp_info:
                min_loc = esp_info['ESP_min_location_Ang']
                min_val = esp_info.get('ESP_min_eV', 0)
                viewer.addSphere({
                    'center': {'x': min_loc[0], 'y': min_loc[1], 'z': min_loc[2]},
                    'radius': 0.3,
                    'color': '#0000FF',
                    'opacity': 0.9
                })
                viewer.addLabel(f"Min: {min_val:.2f} eV", {
                    'position': {'x': min_loc[0], 'y': min_loc[1], 'z': min_loc[2] + 1.0},
                    'fontSize': 10,
                    'fontColor': '#6666FF',
                    'backgroundColor': '#000000',
                    'backgroundOpacity': 0.7
                })
                extrema_html += f'<span style="color: #6666FF;">â— Min: {min_val:.2f} eV</span>'
        
        # è®¾ç½®èƒŒæ™¯å’Œè§†å›¾
        viewer.setBackgroundColor(background_color)
        viewer.zoomTo()
        
        html = viewer._make_html()
        
        # æ„å»ºåŒ…è£… HTML
        wrapper_html = f"""
        <div style="border: 2px solid #4a4a6a; border-radius: 8px; padding: 10px; background: #0d0d1a;">
            <div style="color: #aaa; font-size: 12px; margin-bottom: 5px; text-align: center;">
                ğŸ–±ï¸ å·¦é”®æ‹–åŠ¨æ—‹è½¬ | æ»šè½®ç¼©æ”¾ | å³é”®å¹³ç§»
            </div>
            {html}
            <div style="color: #888; font-size: 11px; margin-top: 5px; text-align: center;">
                é™ç”µåŠ¿ (ESP) | ç­‰å€¼é¢: Â±{pos_iso:.4f} a.u. &nbsp;
                <span style="color: #FF4444;">â– </span> æ­£(äº²æ ¸) &nbsp;
                <span style="color: #4444FF;">â– </span> è´Ÿ(äº²ç”µ)
            </div>
            {f'<div style="color: #888; font-size: 11px; margin-top: 3px; text-align: center;">{extrema_html}</div>' if extrema_html else ''}
        </div>
        """
        
        return wrapper_html
        
    except Exception as e:
        import traceback
        logger.error(f"ESP visualization error: {traceback.format_exc()}")
        return f"<p style='color: red;'>åŠ è½½ ESP å¯è§†åŒ–å¤±è´¥: {e}</p>"


def create_structure_preview_html(db_path: str, max_structures: int = None) -> str:
    """ä¸ºæ•°æ®åº“ä¸­çš„ç»“æ„åˆ›å»º HTML é¢„è§ˆã€‚"""
    # ä½¿ç”¨é…ç½®æ–‡ä»¶ä¸­çš„é»˜è®¤å€¼
    if max_structures is None:
        max_structures = VisualizationConfig.get_max_preview_structures()
    
    if not os.path.exists(db_path):
        return "<p style='color: red;'>ç»“æ„æ–‡ä»¶ä¸å­˜åœ¨</p>"
    
    try:
        with connect(db_path) as db:
            count = db.count()
            
            if count == 0:
                return "<p style='color: orange;'>æ•°æ®åº“ä¸­æ²¡æœ‰ç»“æ„</p>"
            
            html_parts = []
            html_parts.append(f"<div style='text-align: center; color: #888;'>å…± {count} ä¸ªç»“æ„</div>")
            
            for i, row in enumerate(db.select()):
                if i >= max_structures:
                    html_parts.append(f"<p style='color: #888; text-align: center;'>... è¿˜æœ‰ {count - max_structures} ä¸ªç»“æ„</p>")
                    break
                
                atoms = row.toatoms()
                name = row.get('name', f'Structure {i+1}')
                
                viewer_html = create_gaussian_view_style_viewer(
                    atoms, 
                    width=500, 
                    height=400,
                    style="sphere+stick"
                )
                
                html_parts.append(f"""
                <div style="margin: 15px 0; padding: 10px; border: 1px solid #333; border-radius: 8px;">
                    <h4 style="color: #fff; margin: 0 0 10px 0;">{name}</h4>
                    {viewer_html}
                </div>
                """)
            
            return "\n".join(html_parts)
            
    except Exception as e:
        return f"<p style='color: red;'>åŠ è½½ç»“æ„å¤±è´¥: {e}</p>"


def create_analysis_visualization_html(
    db_path: str,
    inference_dir: str,
    width: int = 600,
    height: int = 450
) -> Dict[str, Any]:
    """
    åˆ›å»ºç»“æ„ã€HOMOã€LUMOã€ESP çš„å¯è§†åŒ– HTMLã€‚
    
    Returns:
        åŒ…å« 'structure', 'homo', 'lumo', 'esp' é”®çš„å­—å…¸
    """
    result: Dict[str, Any] = {
        'structure': None,
        'homo': None,
        'lumo': None,
        'esp': None,
        'structure_available': False,
        'homo_available': False,
        'lumo_available': False,
        'esp_available': False
    }
    
    if db_path and os.path.exists(db_path):
        try:
            atoms = load_structure_from_db(db_path)
            if atoms:
                result['structure'] = create_gaussian_view_style_viewer(
                    atoms, width=width, height=height, style="sphere+stick"
                )
                result['structure_available'] = True
        except Exception as e:
            result['structure'] = f"<p style='color: orange;'>ç»“æ„åŠ è½½å¤±è´¥: {e}</p>"
    
    orbital_files = find_orbital_files(inference_dir)
    
    # orbital_files['homo'] æ˜¯åˆ—è¡¨ï¼Œå–ç¬¬ä¸€ä¸ªæ–‡ä»¶çš„è·¯å¾„
    if orbital_files['homo'] and len(orbital_files['homo']) > 0:
        result['homo'] = create_orbital_viewer(
            orbital_files['homo'][0]['path'], 
            width=width, 
            height=height,
            iso_value=0.02,
            orbital_type="HOMO"
        )
        result['homo_available'] = True
    
    if orbital_files['lumo'] and len(orbital_files['lumo']) > 0:
        result['lumo'] = create_orbital_viewer(
            orbital_files['lumo'][0]['path'],
            width=width,
            height=height, 
            iso_value=0.02,
            orbital_type="LUMO"
        )
        result['lumo_available'] = True
    
    # æŸ¥æ‰¾å¹¶åˆ›å»º ESP å¯è§†åŒ–
    # esp_files æ˜¯åˆ—è¡¨ï¼Œå–ç¬¬ä¸€ä¸ªæ–‡ä»¶ç»„
    esp_files = find_esp_files(inference_dir)
    if esp_files and len(esp_files) > 0:
        esp_group = esp_files[0]
        if esp_group.get('density') and esp_group.get('esp'):
            result['esp'] = create_esp_viewer(
                esp_group['density'],
                esp_group['esp'],
                esp_group.get('info'),
                width=width,
                height=height
            )
            result['esp_available'] = True
    
    return result


def generate_high_quality_image(
    atoms: Atoms,
    output_path: str,
    width: int = 1200,
    height: int = 900,
    style: str = "sphere+stick"
) -> str:
    """ç”Ÿæˆé«˜è´¨é‡åˆ†å­é™æ€å›¾åƒã€‚"""
    html_content = create_gaussian_view_style_viewer(atoms, width, height, style)
    
    html_path = output_path.replace('.png', '.html')
    with open(html_path, 'w') as f:
        f.write(f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Molecular Structure</title>
            <script src="https://3Dmol.org/build/3Dmol-min.js"></script>
        </head>
        <body style="margin: 0; padding: 0; background: #1a1a2e;">
            {html_content}
        </body>
        </html>
        """)
    
    return html_path
