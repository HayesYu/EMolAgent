"""
分子可视化模块

使用 py3Dmol 提供 Gaussian View 风格的分子结构可视化。
"""

import os
import json
import glob
from typing import Optional, List, Dict, Any, Tuple
from ase.db import connect
from ase import Atoms
import py3Dmol
import numpy as np

from emolagent.utils.logger import logger
from emolagent.utils.config import VisualizationConfig
from emolagent.utils.i18n import t

# Element colors (CPK coloring scheme similar to Gaussian View)
ELEMENT_COLORS = {
    'H': '#FFFFFF',
    'C': '#909090',
    'N': '#3050F8',
    'O': '#FF0D0D',
    'F': '#90E050',
    'S': '#FFFF30',
    'P': '#FF8000',
    'Cl': '#1FF01F',
    'Br': '#A62929',
    'I': '#940094',
    'Li': '#8F40D4',
    'Na': '#AB5CF2',
    'K': '#8F40D4',
    'Mg': '#8AFF00',
    'Ca': '#3DFF00',
    'Fe': '#E06633',
    'Zn': '#7D80B0',
    'default': '#FF1493'
}

# Atom radii (in Angstroms, scaled for visualization)
ELEMENT_RADII = {
    'H': 0.31, 'C': 0.77, 'N': 0.71, 'O': 0.66, 'F': 0.57,
    'S': 1.05, 'P': 1.07, 'Cl': 1.02, 'Br': 1.20, 'I': 1.39,
    'Li': 1.34, 'Na': 1.54, 'K': 1.96, 'Mg': 1.30, 'Ca': 1.74,
    'Fe': 1.25, 'Zn': 1.22, 'default': 1.0
}


def atoms_to_xyz_string(atoms: Atoms, comment: str = "") -> str:
    """将 ASE Atoms 对象转换为 XYZ 格式字符串。"""
    n_atoms = len(atoms)
    lines = [str(n_atoms), comment]
    
    symbols = atoms.get_chemical_symbols()
    positions = atoms.get_positions()
    
    for sym, pos in zip(symbols, positions):
        lines.append(f"{sym:2s} {pos[0]:12.6f} {pos[1]:12.6f} {pos[2]:12.6f}")
    
    return "\n".join(lines)


def atomic_number_to_symbol(z: int) -> str:
    """将原子序数转换为元素符号。"""
    symbols = ['X', 'H', 'He', 'Li', 'Be', 'B', 'C', 'N', 'O', 'F', 'Ne',
               'Na', 'Mg', 'Al', 'Si', 'P', 'S', 'Cl', 'Ar', 'K', 'Ca',
               'Sc', 'Ti', 'V', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn',
               'Ga', 'Ge', 'As', 'Se', 'Br', 'Kr']
    if 0 <= z < len(symbols):
        return symbols[z]
    return 'X'


def create_gaussian_view_style_viewer(
    atoms: Atoms,
    width: int = 600,
    height: int = 500,
    style: str = "sphere+stick",
    background_color: str = "#1a1a2e",
    show_labels: bool = False,
    add_lighting: bool = True,
    lang: str = "zh",
) -> str:
    """
    创建 Gaussian View 风格的 3D 分子查看器 HTML。
    
    Args:
        atoms: ASE Atoms 对象
        width: 查看器宽度（像素）
        height: 查看器高度（像素）
        style: 渲染样式 ("sphere", "stick", "sphere+stick")
        background_color: 背景颜色
        show_labels: 是否显示原子标签
        add_lighting: 是否添加增强光照效果
        lang: 语言代码 ("zh" 或 "en")
        
    Returns:
        包含交互式 3D 查看器的 HTML 字符串
    """
    xyz_str = atoms_to_xyz_string(atoms, "Generated by EMolAgent")
    
    viewer = py3Dmol.view(width=width, height=height)
    viewer.addModel(xyz_str, "xyz")
    
    if style == "sphere":
        viewer.setStyle({'sphere': {'colorscheme': 'Jmol', 'scale': 0.3}})
    elif style == "stick":
        viewer.setStyle({
            'stick': {'radius': 0.15, 'colorscheme': 'Jmol'},
        })
    else:
        viewer.setStyle({
            'sphere': {'colorscheme': 'Jmol', 'scale': 0.25},
            'stick': {'radius': 0.12, 'colorscheme': 'Jmol'}
        })
    
    viewer.setBackgroundColor(background_color)
    
    if show_labels:
        viewer.addPropertyLabels('elem', '', {'fontSize': 12, 'fontColor': 'white', 'showBackground': False})
    
    viewer.zoomTo()
    
    html = viewer._make_html()
    
    # 多语言文本
    mouse_hint = t("vis_mouse_hint", lang)
    atom_count_label = t("vis_atom_count", lang)
    formula_label = t("chemical_formula", lang)
    
    wrapper_html = f"""
    <div style="border: 2px solid #4a4a6a; border-radius: 8px; padding: 10px; background: #0d0d1a;">
        <div style="color: #aaa; font-size: 12px; margin-bottom: 5px; text-align: center;">
            {mouse_hint}
        </div>
        {html}
        <div style="color: #888; font-size: 11px; margin-top: 5px; text-align: center;">
            {atom_count_label}: {len(atoms)} | {formula_label}: {atoms.get_chemical_formula()}
        </div>
    </div>
    """
    
    return wrapper_html


def load_structure_from_db(db_path: str, index: int = 0) -> Optional[Atoms]:
    """从 ASE 数据库加载结构。"""
    if not os.path.exists(db_path):
        return None
    
    try:
        with connect(db_path) as db:
            if db.count() == 0:
                return None
            row = list(db.select())[index]
            return row.toatoms()
    except Exception as e:
        logger.error(f"Error loading structure: {e}")
        return None


def load_all_structures_from_db(db_path: str, max_count: int = 3) -> List[Tuple[Atoms, Dict[str, Any]]]:
    """
    从 ASE 数据库加载所有结构及其元数据。
    
    Args:
        db_path: 数据库文件路径
        max_count: 最大加载数量，默认为 3
        
    Returns:
        包含 (Atoms, metadata_dict) 元组的列表
    """
    structures: List[Tuple[Atoms, Dict[str, Any]]] = []
    
    if not os.path.exists(db_path):
        return structures
    
    try:
        with connect(db_path) as db:
            total_count = db.count()
            if total_count == 0:
                return structures
            
            for i, row in enumerate(db.select()):
                if i >= max_count:
                    break
                    
                atoms = row.toatoms()
                
                # 提取元数据
                metadata: Dict[str, Any] = {
                    'id': row.id,
                    'name': row.get('name', f'Structure {row.id}'),
                    'category': row.get('category', ''),
                    'solvent_name': row.get('solvent_name', ''),
                    'anion_name': row.get('anion_name', ''),
                    'n_solv': row.get('n_solv', 0),
                    'n_anion': row.get('n_anion', 0),
                    'ion': row.get('ion', 'Li'),
                    'charge': row.get('charge', 0),
                }
                
                structures.append((atoms, metadata))
            
            # 记录总数信息（用于显示"还有 N 个未显示"）
            if structures:
                structures[0][1]['_total_count'] = total_count
                
    except Exception as e:
        logger.error(f"Error loading structures from db: {e}")
    
    return structures


def get_structure_count_from_db(db_path: str) -> int:
    """获取数据库中的结构总数。"""
    if not os.path.exists(db_path):
        return 0
    
    try:
        with connect(db_path) as db:
            return db.count()
    except Exception as e:
        logger.error(f"Error counting structures: {e}")
        return 0


def create_orbital_viewer(
    cube_path: str,
    width: int = 600,
    height: int = 500,
    iso_value: float = 0.02,
    orbital_type: str = "HOMO",
    background_color: str = "#1a1a2e",
    lang: str = "zh",
) -> str:
    """
    创建分子轨道（cube 文件）可视化查看器。
    
    Args:
        cube_path: cube 文件路径
        width: 查看器宽度
        height: 查看器高度
        iso_value: 等值面数值
        orbital_type: 轨道类型 ("HOMO" 或 "LUMO")
        background_color: 背景颜色
        lang: 语言代码 ("zh" 或 "en")
        
    Returns:
        包含交互式 3D 轨道查看器的 HTML 字符串
    """
    if not os.path.exists(cube_path):
        return f"<p style='color: red;'>Cube 文件不存在: {cube_path}</p>"
    
    try:
        with open(cube_path, 'r') as f:
            cube_content = f.read()
        
        viewer = py3Dmol.view(width=width, height=height)
        
        if orbital_type.upper() == "HOMO":
            pos_color = "#1E90FF"
            neg_color = "#FF6347"
        else:
            pos_color = "#32CD32"
            neg_color = "#FFD700"
        
        viewer.addVolumetricData(cube_content, "cube", {
            'isoval': iso_value,
            'color': pos_color,
            'opacity': 0.75,
            'smoothness': 3
        })
        viewer.addVolumetricData(cube_content, "cube", {
            'isoval': -iso_value,
            'color': neg_color,
            'opacity': 0.75,
            'smoothness': 3
        })
        
        viewer.addModel(cube_content, "cube")
        viewer.setStyle({
            'sphere': {'colorscheme': 'Jmol', 'scale': 0.2},
            'stick': {'radius': 0.1, 'colorscheme': 'Jmol'}
        })
        
        viewer.setBackgroundColor(background_color)
        viewer.zoomTo()
        
        html = viewer._make_html()
        
        # 多语言文本
        mouse_hint = t("vis_mouse_hint", lang)
        orbital_label = t("vis_orbital", lang)
        isovalue_label = t("vis_isovalue", lang)
        positive_label = t("vis_positive_phase", lang)
        negative_label = t("vis_negative_phase", lang)
        
        wrapper_html = f"""
        <div style="border: 2px solid #4a4a6a; border-radius: 8px; padding: 10px; background: #0d0d1a;">
            <div style="color: #aaa; font-size: 12px; margin-bottom: 5px; text-align: center;">
                {mouse_hint}
            </div>
            {html}
            <div style="color: #888; font-size: 11px; margin-top: 5px; text-align: center;">
                {orbital_type} {orbital_label} | {isovalue_label}: ±{iso_value} &nbsp;
                <span style="color: {pos_color};">■</span> {positive_label} &nbsp;
                <span style="color: {neg_color};">■</span> {negative_label}
            </div>
        </div>
        """
        
        return wrapper_html
        
    except Exception as e:
        error_msg = t("vis_load_orbital_failed", lang)
        return f"<p style='color: red;'>{error_msg}: {e}</p>"


def find_orbital_files(inference_dir: str) -> Dict[str, List[Dict[str, str]]]:
    """
    在推断结果目录中查找所有 HOMO 和 LUMO cube 文件。
    
    Returns:
        包含 'homo' 和 'lumo' 键的字典，每个值是文件信息列表
        每个文件信息包含 'path', 'id', 'dir_name' 键
    """
    result: Dict[str, List[Dict[str, str]]] = {'homo': [], 'lumo': []}
    
    if not os.path.exists(inference_dir):
        return result
    
    search_patterns = [
        os.path.join(inference_dir, "results", "*", "homo.cube"),
        os.path.join(inference_dir, "results", "*", "lumo.cube"),
        os.path.join(inference_dir, "*", "homo.cube"),
        os.path.join(inference_dir, "*", "lumo.cube"),
        os.path.join(inference_dir, "homo.cube"),
        os.path.join(inference_dir, "lumo.cube"),
    ]
    
    found_homo = set()
    found_lumo = set()
    
    for pattern in search_patterns:
        matches = glob.glob(pattern)
        for match in matches:
            basename = os.path.basename(match).lower()
            parent_dir = os.path.basename(os.path.dirname(match))
            
            # 尝试从目录名提取 id
            try:
                file_id = int(parent_dir) if parent_dir.isdigit() else len(found_homo) + len(found_lumo)
            except:
                file_id = len(found_homo) + len(found_lumo)
            
            if 'homo' in basename and match not in found_homo:
                found_homo.add(match)
                result['homo'].append({
                    'path': match,
                    'id': str(file_id),
                    'dir_name': parent_dir,
                })
            elif 'lumo' in basename and match not in found_lumo:
                found_lumo.add(match)
                result['lumo'].append({
                    'path': match,
                    'id': str(file_id),
                    'dir_name': parent_dir,
                })
    
    # 按 id 排序
    result['homo'].sort(key=lambda x: int(x['id']) if x['id'].isdigit() else 0)
    result['lumo'].sort(key=lambda x: int(x['id']) if x['id'].isdigit() else 0)
    
    return result


def find_li_deformation_files(inference_dir: str) -> List[Dict[str, str]]:
    """
    在推断结果目录中查找 Li deformation surface PDB 文件。
    
    文件名格式: Li_infer_{li_index}_diff{isovalue}_surface.pdb
    文件位于 results/{structure_id}/ 目录下
    
    Returns:
        包含 'path', 'id', 'isovalue', 'li_index' 键的字典列表
        其中 'id' 是结构 ID（目录名），用于匹配 structure_labels
    """
    result: List[Dict[str, str]] = []
    
    if not os.path.exists(inference_dir):
        return result
    
    search_patterns = [
        os.path.join(inference_dir, "results", "*", "Li_*_surface.pdb"),
        os.path.join(inference_dir, "*", "Li_*_surface.pdb"),
        os.path.join(inference_dir, "Li_*_surface.pdb"),
    ]
    
    found_files = set()
    for pattern in search_patterns:
        matches = glob.glob(pattern)
        for match in matches:
            if match not in found_files:
                found_files.add(match)
                basename = os.path.basename(match)
                parent_dir = os.path.basename(os.path.dirname(match))
                
                # 解析文件名: Li_infer_1_diff0p09_surface.pdb
                # 其中 _1_ 是 Li 原子的 1-based 索引（不是结构 ID）
                import re
                m = re.match(r'Li_(\w+)_(\d+)_diff(\w+)_surface\.pdb', basename)
                if m:
                    # 使用父目录名作为结构 ID（与 structure_labels 对应）
                    structure_id = parent_dir if parent_dir.isdigit() else str(len(result))
                    result.append({
                        'path': match,
                        'type': m.group(1),       # infer/pred/target
                        'li_index': m.group(2),   # Li 原子索引（1-based）
                        'id': structure_id,       # 结构 ID（目录名，0-based）
                        'isovalue': m.group(3).replace('p', '.'),  # 0p09 -> 0.09
                    })
    
    # 按结构 id 排序
    result.sort(key=lambda x: int(x.get('id', 0)))
    return result


def create_li_deformation_viewer(
    molecule_path: str,
    surface_pdb_path: str,
    width: int = 600,
    height: int = 500,
    surface_color: str = "#4A90D9",
    surface_opacity: float = 0.65,
    background_color: str = "#1a1a2e",
    isovalue: str = "0.09",
    lang: str = "zh",
) -> str:
    """
    创建 Li deformation factor 可视化查看器。
    
    将点云 PDB 渲染为半透明表面，叠加在分子结构上，
    用于展示 Li 离子周围的电子变形分布。
    
    Args:
        molecule_path: 分子结构文件路径 (xyz 或 pdb)
        surface_pdb_path: Li deformation 点云 PDB 文件路径
        width: 查看器宽度
        height: 查看器高度
        surface_color: 表面颜色（默认冷蓝色）
        surface_opacity: 表面透明度
        background_color: 背景颜色
        isovalue: 等值面值（用于显示）
        lang: 语言代码 ("zh" 或 "en")
        
    Returns:
        包含交互式 3D 查看器的 HTML 字符串
    """
    # 检查文件是否存在
    if not os.path.exists(molecule_path):
        return f"<p style='color: red;'>分子结构文件不存在: {molecule_path}</p>"
    if not os.path.exists(surface_pdb_path):
        return f"<p style='color: red;'>表面点云文件不存在: {surface_pdb_path}</p>"
    
    try:
        # 1. 读取分子结构
        mol_ext = os.path.splitext(molecule_path)[1].lower()
        with open(molecule_path, 'r') as f:
            mol_content = f.read()
        
        # 确定分子文件格式
        if mol_ext == '.xyz':
            mol_format = 'xyz'
        elif mol_ext == '.pdb':
            mol_format = 'pdb'
        else:
            # 尝试自动检测
            mol_format = 'xyz' if mol_content.strip().split('\n')[0].strip().isdigit() else 'pdb'
        
        # 2. 读取表面点云 PDB
        with open(surface_pdb_path, 'r') as f:
            surface_content = f.read()
        
        # 3. 创建 py3Dmol 视图
        viewer = py3Dmol.view(width=width, height=height)
        
        # 4. 添加分子骨架 (Model 0)
        viewer.addModel(mol_content, mol_format)
        viewer.setStyle({'model': 0}, {
            'sphere': {'colorscheme': 'Jmol', 'scale': 0.25},
            'stick': {'radius': 0.12, 'colorscheme': 'Jmol'}
        })
        
        # 5. 添加点云并渲染为表面 (Model 1)
        viewer.addModel(surface_content, 'pdb')
        # 隐藏点云本身的原子显示
        viewer.setStyle({'model': 1}, {'sphere': {'scale': 0}})
        
        # 6. 为点云添加 VDW 表面（近似 QuickSurf 效果）
        # py3Dmol 的 addSurface 支持: VDW, MS (分子表面), SAS, SES
        viewer.addSurface(
            'VDW',
            {
                'opacity': surface_opacity,
                'color': surface_color,
            },
            {'model': 1}
        )
        
        # 7. 设置背景和视图
        viewer.setBackgroundColor(background_color)
        viewer.zoomTo()
        
        # 8. 生成 HTML
        html = viewer._make_html()
        
        # 多语言文本
        mouse_hint = t("vis_mouse_hint", lang)
        isovalue_label = t("vis_isovalue", lang)
        deformation_label = t("vis_deformation_region", lang)
        
        wrapper_html = f"""
        <div style="border: 2px solid #4a4a6a; border-radius: 8px; padding: 10px; background: #0d0d1a;">
            <div style="color: #aaa; font-size: 12px; margin-bottom: 5px; text-align: center;">
                {mouse_hint}
            </div>
            {html}
            <div style="color: #888; font-size: 11px; margin-top: 5px; text-align: center;">
                Li Deformation Factor | {isovalue_label}: {isovalue} &nbsp;
                <span style="display: inline-block; width: 12px; height: 12px; background: {surface_color}; border-radius: 2px; vertical-align: middle;"></span>
                <span style="color: {surface_color};"> {deformation_label}</span>
            </div>
        </div>
        """
        
        return wrapper_html
        
    except Exception as e:
        error_msg = t("vis_load_li_deform_failed", lang)
        return f"<p style='color: red;'>{error_msg}: {e}</p>"


def find_esp_files(inference_dir: str) -> List[Dict[str, Optional[str]]]:
    """
    在推断结果目录中查找所有 ESP 可视化所需的文件。
    
    Returns:
        文件组列表，每组包含 'density', 'esp', 'info', 'id', 'dir_name' 键
    """
    result: List[Dict[str, Optional[str]]] = []
    
    if not os.path.exists(inference_dir):
        return result
    
    # 搜索模式
    search_dirs = [
        os.path.join(inference_dir, "results", "*"),
        os.path.join(inference_dir, "*"),
    ]
    
    found_dirs = set()
    
    for search_dir in search_dirs:
        dirs = glob.glob(search_dir) if '*' in search_dir else [search_dir]
        for d in dirs:
            if not os.path.isdir(d) or d in found_dirs:
                continue
            
            dir_name = os.path.basename(d)
            
            # 查找 density cube 文件
            density_file = None
            density_candidates = [
                os.path.join(d, "infer_ESPCalculator_density.cub"),
                os.path.join(d, "density.cub"),
                os.path.join(d, "density.cube"),
            ]
            for f in density_candidates:
                if os.path.exists(f):
                    density_file = f
                    break
            
            # 查找 ESP cube 文件
            esp_file = None
            esp_candidates = [
                os.path.join(d, "infer_ESPCalculator_totesp.cub"),
                os.path.join(d, "totesp.cub"),
                os.path.join(d, "esp.cub"),
                os.path.join(d, "esp.cube"),
            ]
            for f in esp_candidates:
                if os.path.exists(f):
                    esp_file = f
                    break
            
            # 查找 info json 文件
            info_file = None
            info_candidates = [
                os.path.join(d, "infer_esp_info.json"),
                os.path.join(d, "esp_info.json"),
            ]
            for f in info_candidates:
                if os.path.exists(f):
                    info_file = f
                    break
            
            # 如果找到 density 和 esp 文件，添加到结果
            if density_file and esp_file:
                found_dirs.add(d)
                try:
                    file_id = int(dir_name) if dir_name.isdigit() else len(result)
                except:
                    file_id = len(result)
                
                result.append({
                    'density': density_file,
                    'esp': esp_file,
                    'info': info_file,
                    'id': str(file_id),
                    'dir_name': dir_name,
                })
    
    # 也检查根目录
    density_file = None
    esp_file = None
    info_file = None
    
    for f in [os.path.join(inference_dir, "infer_ESPCalculator_density.cub"),
              os.path.join(inference_dir, "density.cub")]:
        if os.path.exists(f):
            density_file = f
            break
    
    for f in [os.path.join(inference_dir, "infer_ESPCalculator_totesp.cub"),
              os.path.join(inference_dir, "totesp.cub")]:
        if os.path.exists(f):
            esp_file = f
            break
    
    for f in [os.path.join(inference_dir, "infer_esp_info.json"),
              os.path.join(inference_dir, "esp_info.json")]:
        if os.path.exists(f):
            info_file = f
            break
    
    if density_file and esp_file:
        result.append({
            'density': density_file,
            'esp': esp_file,
            'info': info_file,
            'id': str(len(result)),
            'dir_name': 'root',
        })
    
    # 按 id 排序
    result.sort(key=lambda x: int(x['id']) if x['id'].isdigit() else 0)
    
    return result


def load_esp_info(info_path: str) -> Optional[Dict[str, Any]]:
    """
    加载 ESP info JSON 文件。
    
    Returns:
        包含 ESP 最大/最小值及位置的字典
    """
    if not info_path or not os.path.exists(info_path):
        return None
    
    try:
        with open(info_path, 'r') as f:
            return json.load(f)
    except Exception as e:
        logger.error(f"Error loading ESP info: {e}")
        return None


def parse_cube_file(cube_path: str) -> Tuple[List[Dict], np.ndarray, Dict]:
    """
    解析 Gaussian cube 文件格式。
    
    Returns:
        (atoms_list, grid_data, grid_info)
        - atoms_list: 原子列表，每个原子包含 {'symbol', 'x', 'y', 'z'}
        - grid_data: 3D numpy 数组的网格数据
        - grid_info: 网格信息字典
    """
    with open(cube_path, 'r') as f:
        lines = f.readlines()
    
    # 跳过前两行注释
    # 第3行: 原子数和原点坐标
    parts = lines[2].split()
    n_atoms = abs(int(parts[0]))
    origin = [float(parts[1]), float(parts[2]), float(parts[3])]
    
    # 第4-6行: 各轴的网格点数和步长向量
    nx, vx = int(lines[3].split()[0]), [float(x) for x in lines[3].split()[1:4]]
    ny, vy = int(lines[4].split()[0]), [float(x) for x in lines[4].split()[1:4]]
    nz, vz = int(lines[5].split()[0]), [float(x) for x in lines[5].split()[1:4]]
    
    grid_info = {
        'origin': origin,
        'n_points': (nx, ny, nz),
        'vectors': (vx, vy, vz)
    }
    
    # 解析原子信息
    atoms_list = []
    for i in range(n_atoms):
        parts = lines[6 + i].split()
        z = int(float(parts[0]))
        x, y, z_coord = float(parts[2]), float(parts[3]), float(parts[4])
        atoms_list.append({
            'symbol': atomic_number_to_symbol(z),
            'x': x * 0.529177,  # Bohr to Angstrom
            'y': y * 0.529177,
            'z': z_coord * 0.529177
        })
    
    # 解析网格数据
    data_start = 6 + n_atoms
    data_values = []
    for line in lines[data_start:]:
        data_values.extend([float(x) for x in line.split()])
    
    grid_data = np.array(data_values).reshape((nx, ny, nz))
    
    return atoms_list, grid_data, grid_info


def atoms_list_to_xyz_string(atoms_list: List[Dict], comment: str = "") -> str:
    """将原子列表转换为 XYZ 格式字符串。"""
    n_atoms = len(atoms_list)
    lines = [str(n_atoms), comment]
    
    for atom in atoms_list:
        lines.append(f"{atom['symbol']:2s} {atom['x']:12.6f} {atom['y']:12.6f} {atom['z']:12.6f}")
    
    return "\n".join(lines)


def value_to_bwr_color(value: float, vmin: float, vmax: float) -> str:
    """
    将数值映射到 BWR (蓝-白-红) 色阶。
    
    Args:
        value: 要映射的值
        vmin: 最小值（对应蓝色）
        vmax: 最大值（对应红色）
        
    Returns:
        十六进制颜色字符串
    """
    # 归一化到 [-1, 1]
    if vmax == vmin:
        norm = 0
    else:
        mid = (vmax + vmin) / 2
        half_range = (vmax - vmin) / 2
        if half_range == 0:
            norm = 0
        else:
            norm = (value - mid) / half_range
    
    norm = max(-1, min(1, norm))  # clamp
    
    if norm < 0:
        # 蓝到白：增加红和绿
        r = int(255 * (1 + norm))
        g = int(255 * (1 + norm))
        b = 255
    else:
        # 白到红：减少绿和蓝
        r = 255
        g = int(255 * (1 - norm))
        b = int(255 * (1 - norm))
    
    return f"#{r:02x}{g:02x}{b:02x}"


def parse_cube_file_full(cube_path: str) -> Tuple[List[Dict], np.ndarray, Dict]:
    """
    解析 Gaussian cube 文件格式，返回完整的网格信息（用于 marching cubes）。
    
    Returns:
        (atoms_list, grid_data, grid_info)
        - atoms_list: 原子列表，每个原子包含 {'symbol', 'x', 'y', 'z'} (Angstrom)
        - grid_data: 3D numpy 数组的网格数据
        - grid_info: 网格信息字典，包含 origin, n_points, spacing (全部 Bohr 单位)
    """
    with open(cube_path, 'r') as f:
        lines = f.readlines()
    
    # 第3行: 原子数和原点坐标 (Bohr)
    parts = lines[2].split()
    n_atoms = abs(int(parts[0]))
    origin = np.array([float(parts[1]), float(parts[2]), float(parts[3])])
    
    # 第4-6行: 各轴的网格点数和步长向量 (Bohr)
    nx = int(lines[3].split()[0])
    dx = float(lines[3].split()[1])  # 假设是正交网格，只取对角元素
    
    ny = int(lines[4].split()[0])
    dy = float(lines[4].split()[2])
    
    nz = int(lines[5].split()[0])
    dz = float(lines[5].split()[3])
    
    grid_info = {
        'origin': origin,  # Bohr
        'n_points': (nx, ny, nz),
        'spacing': (dx, dy, dz),  # Bohr
    }
    
    # 解析原子信息
    BOHR_TO_ANG = 0.529177
    atoms_list = []
    for i in range(n_atoms):
        parts = lines[6 + i].split()
        z = int(float(parts[0]))
        x_bohr, y_bohr, z_bohr = float(parts[2]), float(parts[3]), float(parts[4])
        atoms_list.append({
            'symbol': atomic_number_to_symbol(z),
            'x': x_bohr * BOHR_TO_ANG,
            'y': y_bohr * BOHR_TO_ANG,
            'z': z_bohr * BOHR_TO_ANG
        })
    
    # 解析网格数据
    data_start = 6 + n_atoms
    data_values = []
    for line in lines[data_start:]:
        data_values.extend([float(x) for x in line.split()])
    
    grid_data = np.array(data_values).reshape((nx, ny, nz))
    
    return atoms_list, grid_data, grid_info


def create_esp_viewer(
    density_cube_path: str,
    esp_cube_path: str,
    esp_info_path: Optional[str] = None,
    width: int = 600,
    height: int = 500,
    density_isovalue: float = 0.001,
    esp_colorscale_min: float = -0.03,
    esp_colorscale_max: float = 0.03,
    surface_opacity: float = 0.85,
    background_color: str = "#1a1a2e",
    show_extrema: bool = True,
    lang: str = "zh",
) -> str:
    """
    创建 ESP (静电势) 映射在分子 vdW 表面上的可视化查看器。
    
    使用 Marching Cubes 从密度 cube 提取等值面，然后用 ESP 值对顶点着色，
    实现类似 VMD 的 BWR 渐变色效果。
    
    Args:
        density_cube_path: 电子密度 cube 文件路径
        esp_cube_path: ESP cube 文件路径
        esp_info_path: ESP info JSON 文件路径（可选）
        width: 查看器宽度
        height: 查看器高度
        density_isovalue: 密度等值面数值（默认 0.001 对应 vdW 表面）
        esp_colorscale_min: ESP 颜色标度最小值（原子单位，默认 -0.03）
        esp_colorscale_max: ESP 颜色标度最大值（原子单位，默认 0.03）
        surface_opacity: 表面透明度
        background_color: 背景颜色
        show_extrema: 是否显示 ESP 极值点
        lang: 语言代码 ("zh" 或 "en")
        
    Returns:
        包含交互式 3D 查看器的 HTML 字符串
    """
    if not os.path.exists(density_cube_path):
        error_msg = t("vis_density_file_not_exist", lang)
        return f"<p style='color: red;'>{error_msg}: {density_cube_path}</p>"
    if not os.path.exists(esp_cube_path):
        error_msg = t("vis_esp_file_not_exist", lang)
        return f"<p style='color: red;'>{error_msg}: {esp_cube_path}</p>"
    
    try:
        from skimage.measure import marching_cubes
        from scipy.interpolate import RegularGridInterpolator
        import plotly.graph_objects as go
        
        BOHR_TO_ANG = 0.529177
        
        # 1. 解析 cube 文件
        atoms_list, density_data, density_info = parse_cube_file_full(density_cube_path)
        _, esp_data, esp_info_grid = parse_cube_file_full(esp_cube_path)
        
        # 加载 ESP info (极值信息)
        esp_info = None
        if esp_info_path:
            esp_info = load_esp_info(esp_info_path)
        
        # 2. 使用 Marching Cubes 提取密度等值面
        origin = density_info['origin']
        nx, ny, nz = density_info['n_points']
        dx, dy, dz = density_info['spacing']
        
        # marching_cubes 返回的顶点是以网格索引为单位，需要转换
        verts, faces, normals, values = marching_cubes(
            density_data,
            level=density_isovalue,
            spacing=(dx, dy, dz)  # Bohr
        )
        
        # 将顶点坐标从网格空间转换到实际坐标 (Bohr -> Angstrom)
        verts_bohr = verts + origin  # 加上原点偏移
        verts_ang = verts_bohr * BOHR_TO_ANG
        
        # 3. 构建 ESP 插值器，在等值面顶点采样 ESP 值
        # ESP 网格坐标 (Bohr)
        esp_origin = esp_info_grid['origin']
        esp_nx, esp_ny, esp_nz = esp_info_grid['n_points']
        esp_dx, esp_dy, esp_dz = esp_info_grid['spacing']
        
        x_esp = np.linspace(esp_origin[0], esp_origin[0] + (esp_nx - 1) * esp_dx, esp_nx)
        y_esp = np.linspace(esp_origin[1], esp_origin[1] + (esp_ny - 1) * esp_dy, esp_ny)
        z_esp = np.linspace(esp_origin[2], esp_origin[2] + (esp_nz - 1) * esp_dz, esp_nz)
        
        esp_interp = RegularGridInterpolator(
            (x_esp, y_esp, z_esp), 
            esp_data,
            method='linear',
            bounds_error=False,
            fill_value=0.0
        )
        
        # 在等值面顶点采样 ESP 值 (使用 Bohr 坐标)
        esp_at_verts = esp_interp(verts_bohr)
        
        # 4. 将 ESP 值映射到 BWR 颜色
        # 归一化 ESP 值到 [0, 1] 范围
        esp_normalized = (esp_at_verts - esp_colorscale_min) / (esp_colorscale_max - esp_colorscale_min)
        esp_normalized = np.clip(esp_normalized, 0, 1)
        
        # BWR 颜色映射：蓝(0) -> 白(0.5) -> 红(1)
        colors = np.zeros((len(esp_normalized), 3))
        
        # 蓝到白 (esp_normalized < 0.5)
        mask_low = esp_normalized < 0.5
        interp_factor = esp_normalized[mask_low] * 2  # 0->0, 0.5->1
        colors[mask_low, 0] = interp_factor  # R: 0->1
        colors[mask_low, 1] = interp_factor  # G: 0->1
        colors[mask_low, 2] = 1  # B: 1
        
        # 白到红 (esp_normalized >= 0.5)
        mask_high = ~mask_low
        interp_factor = (esp_normalized[mask_high] - 0.5) * 2  # 0.5->0, 1->1
        colors[mask_high, 0] = 1  # R: 1
        colors[mask_high, 1] = 1 - interp_factor  # G: 1->0
        colors[mask_high, 2] = 1 - interp_factor  # B: 1->0
        
        # 转换为 Plotly 格式的颜色字符串
        vertex_colors = [f'rgb({int(c[0]*255)},{int(c[1]*255)},{int(c[2]*255)})' for c in colors]
        
        # 5. 创建 Plotly 3D 图形
        fig = go.Figure()
        
        # 添加 ESP 着色的等值面
        fig.add_trace(go.Mesh3d(
            x=verts_ang[:, 0],
            y=verts_ang[:, 1],
            z=verts_ang[:, 2],
            i=faces[:, 0],
            j=faces[:, 1],
            k=faces[:, 2],
            vertexcolor=vertex_colors,
            opacity=surface_opacity,
            name='ESP Surface',
            hoverinfo='skip',
            lighting=dict(
                ambient=0.5,
                diffuse=0.8,
                specular=0.3,
                roughness=0.5,
            ),
            lightposition=dict(x=100, y=200, z=300),
        ))
        
        # 添加分子骨架
        for atom in atoms_list:
            color = ELEMENT_COLORS.get(atom['symbol'], ELEMENT_COLORS['default'])
            radius = ELEMENT_RADII.get(atom['symbol'], ELEMENT_RADII['default']) * 0.3
            
            # 创建球体的近似（使用 scatter3d）
            fig.add_trace(go.Scatter3d(
                x=[atom['x']],
                y=[atom['y']],
                z=[atom['z']],
                mode='markers',
                marker=dict(
                    size=radius * 20,
                    color=color,
                    opacity=1.0,
                ),
                name=atom['symbol'],
                hoverinfo='text',
                hovertext=f"{atom['symbol']} ({atom['x']:.2f}, {atom['y']:.2f}, {atom['z']:.2f})",
                showlegend=False,
            ))
        
        # 添加键（简单版本：基于距离判断）
        bond_x, bond_y, bond_z = [], [], []
        for i, atom1 in enumerate(atoms_list):
            for j, atom2 in enumerate(atoms_list):
                if j <= i:
                    continue
                dist = np.sqrt(
                    (atom1['x'] - atom2['x'])**2 + 
                    (atom1['y'] - atom2['y'])**2 + 
                    (atom1['z'] - atom2['z'])**2
                )
                # 简单的键长判断
                max_bond = 1.8  # Angstrom
                if atom1['symbol'] in ['S', 'P', 'Cl', 'Br', 'I'] or atom2['symbol'] in ['S', 'P', 'Cl', 'Br', 'I']:
                    max_bond = 2.5
                if dist < max_bond:
                    bond_x.extend([atom1['x'], atom2['x'], None])
                    bond_y.extend([atom1['y'], atom2['y'], None])
                    bond_z.extend([atom1['z'], atom2['z'], None])
        
        if bond_x:
            fig.add_trace(go.Scatter3d(
                x=bond_x, y=bond_y, z=bond_z,
                mode='lines',
                line=dict(color='#888888', width=3),
                hoverinfo='skip',
                showlegend=False,
            ))
        
        # 添加 ESP 极值点标注
        extrema_html = ""
        if show_extrema and esp_info:
            if 'ESP_max_location_Ang' in esp_info:
                max_loc = esp_info['ESP_max_location_Ang']
                max_val = esp_info.get('ESP_max_eV', 0)
                fig.add_trace(go.Scatter3d(
                    x=[max_loc[0]], y=[max_loc[1]], z=[max_loc[2]],
                    mode='markers+text',
                    marker=dict(size=8, color='#FF0000', symbol='diamond'),
                    text=[f'Max: {max_val:.2f} eV'],
                    textposition='top center',
                    textfont=dict(color='#FF6666', size=10),
                    hoverinfo='text',
                    hovertext=f'ESP Max: {max_val:.2f} eV',
                    showlegend=False,
                ))
                extrema_html += f'<span style="color: #FF6666;">◆ Max: {max_val:.2f} eV</span> '
            
            if 'ESP_min_location_Ang' in esp_info:
                min_loc = esp_info['ESP_min_location_Ang']
                min_val = esp_info.get('ESP_min_eV', 0)
                fig.add_trace(go.Scatter3d(
                    x=[min_loc[0]], y=[min_loc[1]], z=[min_loc[2]],
                    mode='markers+text',
                    marker=dict(size=8, color='#0000FF', symbol='diamond'),
                    text=[f'Min: {min_val:.2f} eV'],
                    textposition='top center',
                    textfont=dict(color='#6666FF', size=10),
                    hoverinfo='text',
                    hovertext=f'ESP Min: {min_val:.2f} eV',
                    showlegend=False,
                ))
                extrema_html += f'<span style="color: #6666FF;">◆ Min: {min_val:.2f} eV</span>'
        
        # 6. 设置布局
        # 解析背景色
        bg_color = background_color
        
        fig.update_layout(
            scene=dict(
                xaxis=dict(visible=False),
                yaxis=dict(visible=False),
                zaxis=dict(visible=False),
                bgcolor=bg_color,
                aspectmode='data',
            ),
            paper_bgcolor=bg_color,
            plot_bgcolor=bg_color,
            margin=dict(l=0, r=0, t=0, b=0),
            width=width,
            height=height,
            showlegend=False,
        )
        
        # 7. 生成 HTML
        plotly_html = fig.to_html(
            include_plotlyjs='cdn',
            full_html=False,
            config={
                'displayModeBar': True,
                'modeBarButtonsToRemove': ['select2d', 'lasso2d'],
                'displaylogo': False,
            }
        )
        
        # 创建色阶条 HTML (转换为 eV 单位)
        HARTREE_TO_EV = 27.2114
        esp_min_ev = esp_colorscale_min * HARTREE_TO_EV
        esp_max_ev = esp_colorscale_max * HARTREE_TO_EV
        colorbar_html = f"""
        <div style="display: flex; align-items: center; justify-content: center; margin-top: 5px;">
            <span style="color: #4444FF; font-size: 11px;">{esp_min_ev:.2f}</span>
            <div style="
                width: 150px; 
                height: 12px; 
                margin: 0 8px;
                background: linear-gradient(to right, #0000FF, #FFFFFF, #FF0000);
                border-radius: 2px;
            "></div>
            <span style="color: #FF4444; font-size: 11px;">{esp_max_ev:.2f}</span>
            <span style="color: #888; font-size: 10px; margin-left: 5px;">(eV)</span>
        </div>
        """
        
        # 多语言文本
        mouse_hint = t("vis_mouse_hint", lang)
        esp_label = t("vis_esp_label", lang)
        density_iso_label = t("vis_density_isovalue", lang)
        red_positive = t("vis_red_positive", lang)
        blue_negative = t("vis_blue_negative", lang)
        
        wrapper_html = f"""
        <div style="border: 2px solid #4a4a6a; border-radius: 8px; padding: 10px; background: #0d0d1a;">
            <div style="color: #aaa; font-size: 12px; margin-bottom: 5px; text-align: center;">
                {mouse_hint}
            </div>
            {plotly_html}
            <div style="color: #888; font-size: 11px; margin-top: 5px; text-align: center;">
                {esp_label} | {density_iso_label}: {density_isovalue} | 
                <span style="color: #FF4444;">{red_positive}</span> | 
                <span style="color: #4444FF;">{blue_negative}</span>
            </div>
            {colorbar_html}
            {f'<div style="color: #888; font-size: 11px; margin-top: 3px; text-align: center;">{extrema_html}</div>' if extrema_html else ''}
        </div>
        """
        
        return wrapper_html
        
    except ImportError as e:
        missing_pkg = str(e).split("'")[-2] if "'" in str(e) else str(e)
        missing_dep_label = t("vis_missing_dep", lang)
        run_pip_label = t("vis_run_pip", lang)
        return f"""
        <div style="border: 2px solid #ff6666; border-radius: 8px; padding: 15px; background: #1a0d0d;">
            <p style='color: #ff6666; margin: 0;'>
                <strong>{missing_dep_label}:</strong> {missing_pkg}
            </p>
            <p style='color: #aaa; margin: 10px 0 0 0; font-size: 12px;'>
                {run_pip_label}: <code style="background: #333; padding: 2px 6px; border-radius: 3px;">pip install scikit-image scipy plotly</code>
            </p>
        </div>
        """
    except Exception as e:
        import traceback
        logger.error(f"ESP visualization error: {traceback.format_exc()}")
        error_msg = t("vis_load_esp_failed", lang)
        return f"<p style='color: red;'>{error_msg}: {e}</p>"


def create_esp_viewer_fallback(
    density_cube_path: str,
    esp_cube_path: str,
    esp_info_path: Optional[str] = None,
    width: int = 600,
    height: int = 500,
    density_isovalue: float = 0.001,
    esp_colorscale_min: float = -0.03,
    esp_colorscale_max: float = 0.03,
    surface_opacity: float = 0.85,
    background_color: str = "#1a1a2e",
    show_extrema: bool = True,
    lang: str = "zh",
) -> str:
    """
    ESP 可视化的后备方案（使用 py3Dmol，效果较简单）。
    当 scikit-image/plotly 不可用时使用。
    """
    if not os.path.exists(density_cube_path):
        error_msg = t("vis_density_file_not_exist", lang)
        return f"<p style='color: red;'>{error_msg}: {density_cube_path}</p>"
    if not os.path.exists(esp_cube_path):
        error_msg = t("vis_esp_file_not_exist", lang)
        return f"<p style='color: red;'>{error_msg}: {esp_cube_path}</p>"
    
    try:
        with open(density_cube_path, 'r') as f:
            density_content = f.read()
        with open(esp_cube_path, 'r') as f:
            esp_content = f.read()
        
        esp_info = None
        if esp_info_path:
            esp_info = load_esp_info(esp_info_path)
        
        viewer = py3Dmol.view(width=width, height=height)
        
        viewer.addModel(density_content, "cube")
        viewer.setStyle({
            'sphere': {'colorscheme': 'Jmol', 'scale': 0.2},
            'stick': {'radius': 0.1, 'colorscheme': 'Jmol'}
        })
        
        pos_iso = abs(esp_colorscale_max) * 0.5
        viewer.addVolumetricData(esp_content, "cube", {
            'isoval': pos_iso,
            'color': '#FF4444',
            'opacity': 0.6,
            'smoothness': 3
        })
        
        neg_iso = -abs(esp_colorscale_min) * 0.5
        viewer.addVolumetricData(esp_content, "cube", {
            'isoval': neg_iso,
            'color': '#4444FF',
            'opacity': 0.6,
            'smoothness': 3
        })
        
        extrema_html = ""
        if show_extrema and esp_info:
            if 'ESP_max_location_Ang' in esp_info:
                max_loc = esp_info['ESP_max_location_Ang']
                max_val = esp_info.get('ESP_max_eV', 0)
                viewer.addSphere({
                    'center': {'x': max_loc[0], 'y': max_loc[1], 'z': max_loc[2]},
                    'radius': 0.3,
                    'color': '#FF0000',
                    'opacity': 0.9
                })
                extrema_html += f'<span style="color: #FF6666;">● Max: {max_val:.2f} eV</span> '
            
            if 'ESP_min_location_Ang' in esp_info:
                min_loc = esp_info['ESP_min_location_Ang']
                min_val = esp_info.get('ESP_min_eV', 0)
                viewer.addSphere({
                    'center': {'x': min_loc[0], 'y': min_loc[1], 'z': min_loc[2]},
                    'radius': 0.3,
                    'color': '#0000FF',
                    'opacity': 0.9
                })
                viewer.addLabel(f"Min: {min_val:.2f} eV", {
                    'position': {'x': min_loc[0], 'y': min_loc[1], 'z': min_loc[2] + 1.0},
                    'fontSize': 10,
                    'fontColor': '#6666FF',
                    'backgroundColor': '#000000',
                    'backgroundOpacity': 0.7
                })
                extrema_html += f'<span style="color: #6666FF;">● Min: {min_val:.2f} eV</span>'
        
        # 设置背景和视图
        viewer.setBackgroundColor(background_color)
        viewer.zoomTo()
        
        html = viewer._make_html()
        
        # 多语言文本
        mouse_hint = t("vis_mouse_hint", lang)
        esp_label = t("vis_esp_label", lang)
        isovalue_label = t("vis_isovalue", lang)
        positive_label = t("vis_positive_nucleophilic", lang)
        negative_label = t("vis_negative_electrophilic", lang)
        
        # 构建包装 HTML
        wrapper_html = f"""
        <div style="border: 2px solid #4a4a6a; border-radius: 8px; padding: 10px; background: #0d0d1a;">
            <div style="color: #aaa; font-size: 12px; margin-bottom: 5px; text-align: center;">
                {mouse_hint}
            </div>
            {html}
            <div style="color: #888; font-size: 11px; margin-top: 5px; text-align: center;">
                {esp_label} | {isovalue_label}: ±{pos_iso:.4f} a.u. &nbsp;
                <span style="color: #FF4444;">■</span> {positive_label} &nbsp;
                <span style="color: #4444FF;">■</span> {negative_label}
            </div>
            {f'<div style="color: #888; font-size: 11px; margin-top: 3px; text-align: center;">{extrema_html}</div>' if extrema_html else ''}
        </div>
        """
        
        return wrapper_html
        
    except Exception as e:
        import traceback
        logger.error(f"ESP visualization error: {traceback.format_exc()}")
        error_msg = t("vis_load_esp_failed", lang)
        return f"<p style='color: red;'>{error_msg}: {e}</p>"


def create_structure_preview_html(db_path: str, max_structures: int = None) -> str:
    """为数据库中的结构创建 HTML 预览。"""
    # 使用配置文件中的默认值
    if max_structures is None:
        max_structures = VisualizationConfig.get_max_preview_structures()
    
    if not os.path.exists(db_path):
        return "<p style='color: red;'>结构文件不存在</p>"
    
    try:
        with connect(db_path) as db:
            count = db.count()
            
            if count == 0:
                return "<p style='color: orange;'>数据库中没有结构</p>"
            
            html_parts = []
            html_parts.append(f"<div style='text-align: center; color: #888;'>共 {count} 个结构</div>")
            
            for i, row in enumerate(db.select()):
                if i >= max_structures:
                    html_parts.append(f"<p style='color: #888; text-align: center;'>... 还有 {count - max_structures} 个结构</p>")
                    break
                
                atoms = row.toatoms()
                name = row.get('name', f'Structure {i+1}')
                
                viewer_html = create_gaussian_view_style_viewer(
                    atoms, 
                    width=500, 
                    height=400,
                    style="sphere+stick"
                )
                
                html_parts.append(f"""
                <div style="margin: 15px 0; padding: 10px; border: 1px solid #333; border-radius: 8px;">
                    <h4 style="color: #fff; margin: 0 0 10px 0;">{name}</h4>
                    {viewer_html}
                </div>
                """)
            
            return "\n".join(html_parts)
            
    except Exception as e:
        return f"<p style='color: red;'>加载结构失败: {e}</p>"


def create_analysis_visualization_html(
    db_path: str,
    inference_dir: str,
    width: int = 600,
    height: int = 450
) -> Dict[str, Any]:
    """
    创建结构、HOMO、LUMO、ESP 的可视化 HTML。
    
    Returns:
        包含 'structure', 'homo', 'lumo', 'esp' 键的字典
    """
    result: Dict[str, Any] = {
        'structure': None,
        'homo': None,
        'lumo': None,
        'esp': None,
        'structure_available': False,
        'homo_available': False,
        'lumo_available': False,
        'esp_available': False
    }
    
    if db_path and os.path.exists(db_path):
        try:
            atoms = load_structure_from_db(db_path)
            if atoms:
                result['structure'] = create_gaussian_view_style_viewer(
                    atoms, width=width, height=height, style="sphere+stick"
                )
                result['structure_available'] = True
        except Exception as e:
            result['structure'] = f"<p style='color: orange;'>结构加载失败: {e}</p>"
    
    orbital_files = find_orbital_files(inference_dir)
    
    # orbital_files['homo'] 是列表，取第一个文件的路径
    if orbital_files['homo'] and len(orbital_files['homo']) > 0:
        result['homo'] = create_orbital_viewer(
            orbital_files['homo'][0]['path'], 
            width=width, 
            height=height,
            iso_value=0.02,
            orbital_type="HOMO"
        )
        result['homo_available'] = True
    
    if orbital_files['lumo'] and len(orbital_files['lumo']) > 0:
        result['lumo'] = create_orbital_viewer(
            orbital_files['lumo'][0]['path'],
            width=width,
            height=height, 
            iso_value=0.02,
            orbital_type="LUMO"
        )
        result['lumo_available'] = True
    
    # 查找并创建 ESP 可视化
    # esp_files 是列表，取第一个文件组
    esp_files = find_esp_files(inference_dir)
    if esp_files and len(esp_files) > 0:
        esp_group = esp_files[0]
        if esp_group.get('density') and esp_group.get('esp'):
            result['esp'] = create_esp_viewer(
                esp_group['density'],
                esp_group['esp'],
                esp_group.get('info'),
                width=width,
                height=height
            )
            result['esp_available'] = True
    
    return result


def generate_high_quality_image(
    atoms: Atoms,
    output_path: str,
    width: int = 1200,
    height: int = 900,
    style: str = "sphere+stick"
) -> str:
    """生成高质量分子静态图像。"""
    html_content = create_gaussian_view_style_viewer(atoms, width, height, style)
    
    html_path = output_path.replace('.png', '.html')
    with open(html_path, 'w') as f:
        f.write(f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Molecular Structure</title>
            <script src="https://3Dmol.org/build/3Dmol-min.js"></script>
        </head>
        <body style="margin: 0; padding: 0; background: #1a1a2e;">
            {html_content}
        </body>
        </html>
        """)
    
    return html_path
